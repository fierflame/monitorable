{"version":3,"file":"monitorable.min.js","sources":["../src/utils.ts","../src/state.ts","../src/value.ts"],"sourcesContent":["/** 回调函数安全化处理 */\nexport function safeify<T extends any[]>(fn: (...p: T) => void): (...p: T) => void {\n\treturn (...p) => {\n\t\ttry {\n\t\t\tfn(...p);\n\t\t} catch(e) {\n\t\t\tconsole.error(e);\n\t\t}\n\t};\n}\n","import { safeify } from './utils';\n\nconst ValueMap = new WeakMap<object | Function, object | Function>();\nconst ProxyHandler: ProxyHandler<any> = {\n\tget(target, prop, receiver) {\n\t\tmarkRead(target, typeof prop === 'number' ? String(prop) : prop);\n\t\treturn Reflect.get(target, prop, receiver);\n\t\t// return getProxy(Reflect.get(target, prop, receiver));\n\t},\n\tset(target, prop, value, receiver) {\n\t\tif (Reflect.get(target, prop, receiver) !== value) {\n\t\t\tmarkChange(target, typeof prop === 'number' ? String(prop) : prop);\n\t\t}\n\t\treturn Reflect.set(target, prop, value, receiver);\n\t},\n\t// getOwnPropertyDescriptor(target, prop) {\n\t// \tmarkRead(target, typeof prop === 'number' ? String(prop) : prop);\n\t// \tconst descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\t// \tif (descriptor && 'value' in descriptor) {\n\t// \t\tdescriptor.value = getProxy(descriptor.value);\n\t// \t}\n\t// \treturn descriptor;\n\t// },\n\t// defineProperty(target, prop, attributes) {\n\t// \t// TODO\n\t// \treturn Reflect.defineProperty(target, prop, attributes);\n\t// },\n\t// deleteProperty(target, prop) {\n\t// \t// TODO\n\t// \treturn Reflect.deleteProperty(target, prop);\n\t// },\n\t// enumerate(target) {\n\t// \t// TODO\n\t// \treturn [...Reflect.enumerate(target)];\n\t// },\n};\n\nfunction isProxyable(v: any): v is object | Function {\n\treturn Boolean(v && ['object', 'function'].includes(typeof v));\n}\n\nexport function getProxy<T>(v: T): T {\n\tif (!isProxyable(v)) { return v; }\n\tif (ValueMap.has(v)) { return v; }\n\treturn new Proxy(v, ProxyHandler);\n}\nexport function getValue<T>(v: T): T {\n\treturn ValueMap.get(v as any) as T | undefined || v;\n}\nexport function equal(a: any, b: any): boolean {\n\treturn getValue(a) === getValue(b);\n}\n\n/** 已被读取的 */\nlet read: Map<object | Function, Set<string | symbol>> | undefined;\nexport function markRead(obj: object | Function, prop: string | symbol) {\n\tif (!read) { return; }\n\tlet set = read.get(obj);\n\tif (!set) {\n\t\tset = new Set();\n\t\tread.set(obj, set);\n\t}\n\tset.add(prop);\n}\nexport interface Executable<T> {\n\t(): T;\n\tstop(): void;\n}\nexport function createExecutable<T>(fn: () => T, cb: (changed: boolean) => void): Executable<T> {\n\tcb = safeify(cb);\n\tlet cancelList: (() => void)[] | undefined;\n\t/** 取消监听 */\n\tfunction cancel() {\n\t\tif (!cancelList) { return false; }\n\t\tconst list = cancelList;\n\t\tcancelList = undefined;\n\t\tlist.forEach(f => f());\n\t\treturn true;\n\t}\n\tfunction trigger() {\n\t\tif (!cancel()) { return; }\n\t\tcb(true);\n\t};\n\tfunction exec() {\n\t\tcancel();\n\t\tconst thisRead: typeof read = new Map();\n\t\tconst oldRead = read;\n\t\tread = thisRead;\n\t\ttry {\n\t\t\treturn fn();\n\t\t} catch (e) {\n\t\t\tthisRead.clear();\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tread = oldRead;\n\t\t\tif (thisRead.size) {\n\t\t\t\tcancelList = [];\n\t\t\t\tfor ( let [obj, props] of thisRead) {\n\t\t\t\t\tfor (const p of props) {\n\t\t\t\t\t\tcancelList.push(watchProp(obj, p, trigger));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcb(false);\n\t\t\t}\n\t\t}\n\t}\n\texec.stop = () => {\n\t\tif (!cancel()) { return; }\n\t\tcb(false);\n\t};\n\treturn exec;\n}\n\n\nexport const watchList = new WeakMap<object | Function, Map<string | symbol, (() => void)[]>>();\n\n/**\n * 监听对象属性的变化\n * @param v 要监听属性的值\n * @param key 要监听的属性名\n * @param f 属性改变后触发的函数\n */\nexport function watchProp(v: object | Function, key: string | symbol, f: () => void): () => void {\n\tif (!v) { return () => {}; }\n\tif (!(typeof v === 'object' || typeof v === 'function')) { return () => {}; }\n\tif (typeof f !== 'function') { return  () => {}; }\n\tif (typeof key !== 'symbol' && typeof key !== 'string') { return () => {}; }\n\tv = getValue(v);\n\tlet map = watchList.get(v);\n\tif (!map) {\n\t\tmap = new Map();\n\t\twatchList.set(v, map);\n\t}\n\tlet list = map.get(key);\n\tif (!list) {\n\t\tlist = [];\n\t\tmap.set(key, list);\n\t}\n\tlist.push(f);\n\tlet removed = false;\n\treturn () => {\n\t\tif (removed) { return; }\n\t\tremoved = true;\n\n\t\t// 从当前列表中移除\n\t\tif (!list) { return; }\n\t\tconst index = list.findIndex(a => a === f);\n\t\tif (index < 0) { return; }\n\t\tlist.splice(index, 1);\n\n\t\t// 从属性关联中删除\n\t\tif (list.length) { return; }\n\t\tif (!map) { return; }\n\t\tmap.delete(key);\n\n\t\t// 映射列表中删除\n\t\tif (map.size) { return; }\n\t\twatchList.delete(v);\n\t};\n\n}\n\n/** \n * 标记属性的修改，同时触发监听函数\n */\nexport function markChange(v: object | Function, key: string | symbol) {\n\tif (!v) { return; }\n\tif (!(typeof v === 'object' || typeof v === 'function')) { return; }\n\tif (typeof key === 'number') {\n\t\tkey = String(key);\n\t} else if (typeof key !== 'symbol' && typeof key !== 'string') {\n\t\treturn;\n\t}\n\n\tconst watch = watchList.get(v)?.get?.(key);\n\tif (!watch) { return; }\n\tfor (const w of [...watch]) {\n\t\ttry {\n\t\t\tw();\n\t\t} catch(e){\n\t\t\tconsole.error(e);\n\t\t}\n\t}\n}\n","import { markRead, markChange, createExecutable, getValue, getProxy } from './state';\nimport { safeify } from './utils';\n\n/** 取消监听的方法 */\nexport interface CancelWatch {\n\t(): void;\n}\n/** 可监听值 */\nexport interface Value<T> {\n\t(): T;\n\t(v: T, mrak?: boolean): T;\n\tvalue: T;\n\twatch(cb: WatchCallback<T, this>): CancelWatch;\n\tstop(): void;\n}\n/** 监听函数 */\nexport interface WatchCallback<T, V extends Value<T> = Value<T>> {\n\t(v: V, stoped: boolean): void;\n}\nconst values = new WeakSet<Value<any>>();\nexport function isValue(x: any): x is Value<any> {\n\treturn values.has(x);\n}\n/** 触发监听 */\ninterface Trigger {\n\t(): void;\n\t/** 是否存在监听函数 */\n\thas(): boolean;\n\t/** 停止监听 */\n\tstop(): void;\n}\nexport interface Options {\n\tproxy?: boolean;\n}\n\n\nfunction createValue<T, V extends Value<T> = Value<T>>(\n\tsetValue: (value: T, markChange: () => void) => void,\n\tgetValue: () => T,\n\tstop: () => void = () => {},\n\tchange: () => void = () => {},\n) {\n\tfunction set(v: T, marked = false) {\n\t\ttry {\n\t\t\treturn setValue(v, () => { marked = true; });\n\t\t} finally {\n\t\t\tif (marked) {\n\t\t\t\ttrigger();\n\t\t\t}\n\t\t}\n\t}\n\tfunction get() {\n\t\tmarkRead(value, 'value');\n\t\treturn getValue();\n\t}\n\tconst value: V = ((...v: [T] | [T, boolean] | []): T => {\n\t\tif (v.length) {\n\t\t\tset(v[0], v[1]);\n\t\t\treturn v[0];\n\t\t}\n\t\treturn get();\n\t}) as V;\n\tReflect.defineProperty(value, 'value', {\n\t\tget,\n\t\tset,\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t});\n\n\tfunction watch(cb: WatchCallback<T, V>): () => void {\n\t\tif (!callbacks) { return () => {}; }\n\t\tcb = safeify(cb);\n\t\tcallbacks.push(cb);\n\t\tchange();\n\t\tlet cancelled = false;\n\t\treturn () => {\n\t\t\tif (cancelled) { return; }\n\t\t\tcancelled = true;\n\t\t\tif (!callbacks) { return; }\n\t\t\tconst index = callbacks.findIndex(a => a === cb);\n\t\t\tif (index < 0) { return; }\n\t\t\tcallbacks.splice(index, 1);\n\t\t\tchange();\n\t\t};\n\t}\n\tlet callbacks: WatchCallback<T, V>[] | undefined = [];\n\tReflect.defineProperty(value, 'watch', {\n\t\tget() { return watch; },\n\t\tset() {},\n\t\tconfigurable: true,\n\t});\n\tconst trigger = (() => {\n\t\tif (!callbacks) { return; }\n\t\tmarkChange(value, 'value');\n\t\tfor (const cb of [...callbacks]) {\n\t\t\tcb(value, false);\n\t\t}\n\t}) as Trigger;\n\ttrigger.has = () => Boolean(callbacks?.length);\n\ttrigger.stop = () => {\n\t\tif (!callbacks) { return; }\n\t\tconst list = callbacks;\n\t\tcallbacks = undefined;\n\t\tfor (const cb of [...list]) {\n\t\t\tcb(value, true);\n\t\t}\n\t};\n\tvalues.add(value);\n\tlet stoped = false;\n\tvalue.stop = () => {\n\t\tif (stoped) { return; }\n\t\tstoped = true;\n\t\tstop();\n\t\ttrigger.stop();\n\n\t};\n\treturn {value, trigger};\n}\nexport function value<T>(value: T, options?: Options | boolean): Value<T>;\nexport function value<T>(def: T, options?: Options | boolean): Value<T> {\n\tconst proxy = options === true || options && options.proxy;\n\tlet source: T;\n\tlet proxyed: T;\n\tconst { value } = createValue<T>(\n\t\t(v, mark) => {\n\t\t\tif (proxy) { v = getValue(v); }\n\t\t\tif (v === source) { return; }\n\t\t\tsource = v;\n\t\t\tproxyed = proxy ? getProxy(source) : source;\n\t\t\tmark();\n\t\t},\n\t\t() => proxyed,\n\t);\n\tvalue(def);\n\treturn value;\n}\n\n/** 计算值 */\nexport function computed<T>(source: () => T, options?: Options | boolean): Value<T>;\nexport function computed<T>(getter: () => T, options?: Options | boolean): Value<T> {\n\tconst proxy = options === true || options && options.proxy;\n\tlet source: T;\n\tlet proxyed: T;\n\tlet stoped = false;\n\tlet computed = false;\n\tlet trigger: Trigger | undefined;\n\tconst executable = createExecutable(getter, changed => {\n\t\tcomputed = !changed;\n\t\tif (changed  && trigger) {\n\t\t\ttrigger();\n\t\t}\n\t});\n\tfunction run() {\n\t\tcomputed = true;\n\t\ttry {\n\t\t\tsource = executable();\n\t\t\tif (proxy) { source = getValue(source); }\n\t\t\tproxyed = proxy ? getProxy(source) : source;\n\t\t\treturn proxyed;\n\t\t} catch(e) {\n\t\t\tif (!stoped) {\n\t\t\t\tcomputed = false;\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\n\t}\n\tlet value: Value<T>;\n\t({value, trigger} = createValue<T, Value<T>>(\n\t\t(v: T, mark) => {\n\t\t\t// TODO\n\t\t\t// v = getValue(v);\n\t\t\t// if (v === source) { return; }\n\t\t\t// source = v;\n\t\t\t// mark();\n\t\t},\n\t\t() => computed || stoped ? proxyed : run(),\n\t\t() => {\n\t\t\tif (stoped) { return; }\n\t\t\tstoped = true;\n\t\t\tif (computed) { return; }\n\t\t\trun();\n\t\t},\n\t));\n\treturn value;\n\n}\n\nexport function merge<T, V extends Value<T> = Value<T>>(cb: WatchCallback<T, V>): WatchCallback<T, V> {\n\tlet oldValue: any;\n\tlet runed = false;\n\treturn (v, stoped) => {\n\t\tif (stoped) { return cb(v, stoped); }\n\t\tconst newValue = getValue(v());\n\t\tif (newValue === oldValue && runed) { return; }\n\t\truned = true;\n\t\toldValue = newValue;\n\t\tcb(v, stoped);\n\t};\n}\n\ntype OffValue<V> = V extends Value<infer T> ? T : V;\n\nexport function mix<T extends object>(source: T): { [K in keyof T]: OffValue<T[K]>; } {\n\tfor (const k of Reflect.ownKeys(source)) {\n\t\tconst descriptor = Reflect.getOwnPropertyDescriptor(source, k);\n\t\tif (!descriptor) { continue; }\n\t\tif ('get' in descriptor || 'set' in descriptor || !('value' in descriptor)) { continue; }\n\t\tconst value = descriptor.value;\n\t\tif (!isValue(value)) { continue; }\n\t\tdescriptor.get = () => value();\n\t\tif (descriptor.writable) {\n\t\t\tdescriptor.set = (v) => value(v);\n\t\t}\n\t\tdelete descriptor.value;\n\t\tdelete descriptor.writable;\n\t\tReflect.defineProperty(source, k, descriptor);\n\t}\n\treturn source as any;\n}\n"],"names":["safeify","fn","p","e","console","error","ValueMap","WeakMap","ProxyHandler","get","target","prop","receiver","markRead","String","Reflect","set","value","markChange","getProxy","v","Boolean","includes","isProxyable","has","Proxy","getValue","read","obj","Set","add","watchList","watchProp","key","f","map","Map","list","push","removed","index","findIndex","a","splice","length","delete","size","watch","_watchList$get","_watchList$get$get","w","values","WeakSet","isValue","x","createValue","setValue","stop","change","marked","trigger","cb","callbacks","cancelled","defineProperty","enumerable","configurable","_callbacks","undefined","stoped","getter","options","proxy","source","proxyed","computed","executable","cancelList","cancel","forEach","exec","thisRead","oldRead","clear","props","createExecutable","changed","run","mark","oldValue","runed","newValue","k","ownKeys","descriptor","getOwnPropertyDescriptor","writable","def"],"mappings":";;;;;yMACO,SAASA,EAAyBC,SACjC,IAAIC,SAETD,KAAMC,GACL,MAAMC,GACPC,QAAQC,MAAMF,KCJjB,MAAMG,EAAW,IAAIC,QACfC,EAAkC,CACvCC,IAAG,CAACC,EAAQC,EAAMC,KACjBC,EAASH,EAAwB,iBAATC,EAAoBG,OAAOH,GAAQA,GACpDI,QAAQN,IAAIC,EAAQC,EAAMC,IAGlCI,IAAG,CAACN,EAAQC,EAAMM,EAAOL,KACpBG,QAAQN,IAAIC,EAAQC,EAAMC,KAAcK,GAC3CC,EAAWR,EAAwB,iBAATC,EAAoBG,OAAOH,GAAQA,GAEvDI,QAAQC,IAAIN,EAAQC,EAAMM,EAAOL,KA4BnC,SAASO,EAAYC,UAJ5B,SAAqBA,UACbC,QAAQD,GAAK,CAAC,SAAU,YAAYE,gBAAgBF,IAItDG,CAAYH,GACbd,EAASkB,IAAIJ,GAAaA,EACvB,IAAIK,MAAML,EAAGZ,GAFUY,EAIxB,SAASM,EAAYN,UACpBd,EAASG,IAAIW,IAA8BA,EAOnD,IAAIO,EACG,SAASd,EAASe,EAAwBjB,OAC3CgB,aACDX,EAAMW,EAAKlB,IAAImB,GACdZ,IACJA,EAAM,IAAIa,IACVF,EAAKX,IAAIY,EAAKZ,IAEfA,EAAIc,IAAInB,GAqDF,MAAMoB,EAAY,IAAIxB,QAQtB,SAASyB,EAAUZ,EAAsBa,EAAsBC,OAChEd,QAAY,UACE,iBAANA,GAA+B,mBAANA,QAA4B,UACjD,mBAANc,QAA4B,UACpB,iBAARD,GAAmC,iBAARA,QAA2B,OACjEb,EAAIM,EAASN,OACTe,EAAMJ,EAAUtB,IAAIW,GACnBe,IACJA,EAAM,IAAIC,IACVL,EAAUf,IAAII,EAAGe,QAEdE,EAAOF,EAAI1B,IAAIwB,GACdI,IACJA,EAAO,GACPF,EAAInB,IAAIiB,EAAKI,IAEdA,EAAKC,KAAKJ,OACNK,GAAU,QACP,QACFA,YACJA,GAAU,GAGLF,eACCG,EAAQH,EAAKI,UAAUC,GAAKA,IAAMR,GACpCM,EAAQ,IACZH,EAAKM,OAAOH,EAAO,GAGfH,EAAKO,QACJT,IACLA,EAAIU,OAAOZ,GAGPE,EAAIW,MACRf,EAAUc,OAAOzB,MAQZ,SAASF,EAAWE,EAAsBa,eAC3Cb,YACc,iBAANA,GAA+B,mBAANA,YACnB,iBAARa,EACVA,EAAMnB,OAAOmB,QACP,GAAmB,iBAARA,GAAmC,iBAARA,eAIvCc,YAAQhB,EAAUtB,IAAIW,iCAAd4B,EAAkBvC,wBAAlBwC,SAAwBhB,MACjCc,MACA,MAAMG,IAAK,IAAIH,OAElBG,IACC,MAAM/C,GACPC,QAAQC,MAAMF,IClKjB,MAAMgD,EAAS,IAAIC,QACZ,SAASC,EAAQC,UAChBH,EAAO3B,IAAI8B,GAenB,SAASC,EACRC,EACA9B,EACA+B,EAAmB,SACnBC,EAAqB,mBAEZ1C,EAAII,EAAMuC,GAAS,cAEnBH,EAASpC,EAAG,KAAQuC,GAAS,YAEhCA,GACHC,cAIMnD,WACRI,EAASI,EAAO,SACTS,UAEFT,EAAY,IAAIG,IACjBA,EAAEwB,QACL5B,EAAII,EAAE,GAAIA,EAAE,IACLA,EAAE,IAEHX,aASCsC,EAAMc,OACTC,QAAoB,OACzBD,EAAK7D,EAAQ6D,GACbC,EAAUxB,KAAKuB,GACfH,QACIK,GAAY,QACT,QACFA,YACJA,GAAY,GACPD,eACCtB,EAAQsB,EAAUrB,UAAUC,GAAKA,IAAMmB,GACzCrB,EAAQ,IACZsB,EAAUnB,OAAOH,EAAO,GACxBkB,MApBF3C,QAAQiD,eAAe/C,EAAO,QAAS,CACtCR,IAAAA,EACAO,IAAAA,EACAiD,YAAY,EACZC,cAAc,QAmBXJ,EAA+C,GACnD/C,QAAQiD,eAAe/C,EAAO,QAAS,CACtCR,IAAG,IAAYsC,EACf/B,QACAkD,cAAc,UAETN,EAAW,QACXE,GACL5C,EAAWD,EAAO,aACb,MAAM4C,IAAM,IAAIC,GACpBD,EAAG5C,GAAO,KAGZ2C,EAAQpC,IAAM,kBAAMH,kBAAQyC,sBAAAK,EAAWvB,SACvCgB,EAAQH,KAAO,SACTK,eACCzB,EAAOyB,EACbA,OAAYM,MACP,MAAMP,IAAM,IAAIxB,GACpBwB,EAAG5C,GAAO,IAGZkC,EAAOrB,IAAIb,OACPoD,GAAS,SACbpD,EAAMwC,KAAO,KACRY,IACJA,GAAS,EACTZ,IACAG,EAAQH,SAGF,CAACxC,MAAAA,EAAO2C,QAAAA,cAuBT,SAAqBU,EAAiBC,SACtCC,GAAoB,IAAZD,GAAoBA,GAAWA,EAAQC,UACjDC,EACAC,EAGAd,EAFAS,GAAS,EACTM,GAAW,QAETC,ED9EA,SAA6B3E,EAAa4D,OAE5CgB,WAEKC,QACHD,SAAqB,QACpBxC,EAAOwC,SACbA,OAAaT,EACb/B,EAAK0C,QAAQ7C,GAAKA,MACX,WAEC0B,IACHkB,KACLjB,GAAG,YAEKmB,IACRF,UACMG,EAAwB,IAAI7C,IAC5B8C,EAAUvD,EAChBA,EAAOsD,aAEChF,IACN,MAAOE,SACR8E,EAASE,QACHhF,aAENwB,EAAOuD,EACHD,EAASnC,KAAM,CAClB+B,EAAa,OACP,IAAKjD,EAAKwD,KAAUH,MACpB,MAAM/E,KAAKkF,EACfP,EAAWvC,KAAKN,EAAUJ,EAAK1B,EAAG0D,SAIpCC,GAAG,WAlCNA,EAAK7D,EAAQ6D,GAsCbmB,EAAKvB,KAAO,KACNqB,KACLjB,GAAG,IAEGmB,ECmCYK,CAAiBf,EAAQgB,IAC3CX,GAAYW,EACRA,GAAY1B,GACfA,eAGO2B,IACRZ,GAAW,aAEVF,EAASG,IACLJ,IAASC,EAAS/C,EAAS+C,IAC/BC,EAAUF,EAAQrD,EAASsD,GAAUA,EAC9BC,EACN,MAAMvE,SACFkE,IACJM,GAAW,GAENxE,OAIJc,UACFA,MAAAA,EAAO2C,QAAAA,GAAWL,EACnB,CAACnC,EAAMoE,OAOP,IAAMb,GAAYN,EAASK,EAAUa,IACrC,KACKlB,IACJA,GAAS,EACLM,GACJY,QAGKtE,uBAID,SAAiD4C,OACnD4B,EACAC,GAAQ,QACL,CAACtE,EAAGiD,QACNA,SAAiBR,EAAGzC,EAAGiD,SACrBsB,EAAWjE,EAASN,KACtBuE,IAAaF,GAAYC,IAC7BA,GAAQ,EACRD,EAAWE,EACX9B,EAAGzC,EAAGiD,YAMD,SAA+BI,OAChC,MAAMmB,KAAK7E,QAAQ8E,QAAQpB,GAAS,OAClCqB,EAAa/E,QAAQgF,yBAAyBtB,EAAQmB,OACvDE,cACD,QAASA,GAAc,QAASA,KAAgB,UAAWA,kBACzD7E,EAAQ6E,EAAW7E,MACpBoC,EAAQpC,KACb6E,EAAWrF,IAAM,IAAMQ,IACnB6E,EAAWE,WACdF,EAAW9E,IAAOI,GAAMH,EAAMG,WAExB0E,EAAW7E,aACX6E,EAAWE,SAClBjF,QAAQiD,eAAeS,EAAQmB,EAAGE,WAE5BrB,WAnGD,SAAkBwB,EAAQ1B,SAC1BC,GAAoB,IAAZD,GAAoBA,GAAWA,EAAQC,UACjDC,EACAC,QACEzD,MAAEA,GAAUsC,EACjB,CAACnC,EAAGoE,KACChB,IAASpD,EAAIM,EAASN,IACtBA,IAAMqD,IACVA,EAASrD,EACTsD,EAAUF,EAAQrD,EAASsD,GAAUA,EACrCe,MAED,IAAMd,UAEPzD,EAAMgF,GACChF"}