{"version":3,"file":"monitorable.min.js","sources":["../src/utils.ts","../src/mark.ts","../src/exec.ts","../src/monitor.ts","../src/value.ts","../src/valueExt.ts","../src/merge.ts","../src/object.ts","../src/encase.ts"],"sourcesContent":["\nlet printErrorLog: undefined | ((info: any) => void);\n/** 打印错误 */\nexport function printError(info: any) {\n\tif (typeof printErrorLog === 'function') {\n\t\tprintErrorLog(info);\n\t\treturn;\n\t}\n\tconsole.error(info);\n}\n\nexport function setPrintError(p?: (info: any) => void) {\n\tprintErrorLog = typeof p === 'function' ? p : undefined;\n}\n\n/**\n * 判断对象是否可被代理\n */\nexport function encashable(v: any): v is object | Function {\n\treturn Boolean(v && ['object', 'function'].includes(typeof v));\n}\n\n\n/** 回调函数安全化处理 */\nexport function safeify<T extends any[]>(\n\tfn: (...p: T) => void\n): (...p: T) => void {\n\treturn (...p) => {\n\t\ttry {\n\t\t\tfn(...p);\n\t\t} catch(e) {\n\t\t\tprintError(e);\n\t\t}\n\t};\n}\n\n/** 回调函数安全化处理 */\nexport function safeCall(\n\tfn: () => void\n): void {\n\ttry {\n\t\tfn();\n\t} catch(e) {\n\t\tprintError(e);\n\t}\n}\nexport function getIndexes(\n\ttarget: any,\n\tprop: string | number | symbol | boolean,\n): [object | Function, string | boolean | symbol] | undefined {\n\tif (!target) { return undefined; }\n\tif (typeof target !== 'function' && typeof target !== 'object') {\n\t\treturn undefined;\n\t}\n\tif (typeof prop === 'number') { return [target, String(prop)]; }\n\tif (typeof prop === 'symbol') { return [target, prop]; }\n\tif (typeof prop === 'string') { return [target, prop]; }\n\tif (typeof prop === 'boolean') { return [target, prop]; }\n\treturn undefined;\n}\nexport function getMapValue<K, V>(\n\tmap: Map<K, V>,\n\tkey: K,\n\tdef: () => V,\n): V;\nexport function getMapValue<K extends object, V>(\n\tmap: WeakMap<K, V>,\n\tkey: K,\n\tdef: () => V,\n): V;\nexport function getMapValue<K, V>(\n\tmap: WeakMap<K & object, V> | Map<K, V>,\n\tkey: K,\n\tdef: () => V,\n): V {\n\tif (map.has(key as any)) {\n\t\treturn map.get(key as any)!;\n\t}\n\tconst value = def();\n\tmap.set(key as any, value);\n\treturn value;\n}\n","import { safeify, getMapValue, getIndexes } from './utils';\n\nexport type ReadMap = Map<\n\tobject | Function,\n\tMap<string | boolean | symbol, boolean>\n>;\n\n/** 已被读取的 */\nlet read: ReadMap | undefined;\n\n/**\n * 标记已读状态\n * @param obj  要标记的对象\n * @param prop 要标记的属性\n */\nexport function markRead(\n\ttarget: object | Function,\n\tprop: string | number | boolean | symbol,\n) {\n\tif (!read) { return; }\n\tconst indexes = getIndexes(target, prop);\n\tif (!indexes) { return; }\n\t[target, prop] = indexes;\n\tconst propMap = getMapValue(read, target, () => new Map());\n\tif (propMap.has(prop)) { return; }\n\tpropMap.set(prop, false);\n}\nexport interface ObserveOptions {\n\tpostpone?: boolean | 'priority';\n}\n/**\n * 监听函数的执行，并将执行过程中读取的对象值设置到 map 中\n * @param fn 要执行的含糊\n * @param map 用于存储被读取对象的 map\n */\nfunction observeRun<T>(\n\tmap: ReadMap,\n\tfn: () => T,\n\toptions?: ObserveOptions,\n): T {\n\tconst oldRead = read;\n\tread = map;\n\ttry {\n\t\tif (!options?.postpone) { return fn(); }\n\t\treturn postpone(fn, options.postpone === 'priority');\n\t} finally {\n\t\tread = oldRead;\n\t}\n}\nexport function observe<T>(\n\tmap: ReadMap,\n\tfn: () => T,\n\tpriority?: ObserveOptions,\n): T;\nexport function observe<T>(\n\tmap: ReadMap,\n\tpriority: ObserveOptions,\n\tf: () => T,\n): T;\nexport function observe<T>(\n\tmap: ReadMap,\n\tfn: (() => T) | ObserveOptions | undefined,\n\toptions?: (() => T) | ObserveOptions | undefined\n): T;\nexport function observe<T>(\n\tmap: ReadMap,\n\tfn: (() => T) | ObserveOptions | undefined,\n\toptions?: (() => T) | ObserveOptions | undefined\n): T {\n\n\tif (typeof fn === 'function') {\n\t\treturn observeRun(map, fn, options as ObserveOptions | undefined);\n\t}\n\tif (typeof options !== 'function') {\n\t\tthrow new Error('fn needs to be a function');\n\t}\n\treturn observeRun(map, options, fn);\n}\n\n\nconst watchList = new WeakMap<\n\tobject | Function,\n\tMap<string | boolean | symbol, Set<[() => void, boolean]>>\n>();\n\nfunction execWatch(\n\ttarget: object | Function,\n\tprop: string | boolean | symbol,\n\tfilter?: (isNonDeforred: boolean) => boolean,\n) {\n\tconst watch = watchList.get(target)?.get(prop);\n\tif (!watch) { return; }\n\tlet list = [...watch];\n\tif (filter) {\n\t\tlist = list.filter(([, t]) => filter(t));\n\t}\n\tlist.forEach(([w]) => w());\n}\n\ntype MarkMap = Map<\n\tobject | Function,\n\tSet<string | boolean | symbol>\n>;\nlet waitList: MarkMap | undefined;\n\nfunction runDeferred(list: MarkMap) {\n\tfor (const [target, set] of list.entries()) {\n\t\tconst propMap = read?.get(target);\n\t\tfor (const prop of set) {\n\t\t\texecWatch(target, prop, t => !t);\n\t\t\tif (propMap?.has(prop)) {\n\t\t\t\tpropMap.set(prop, true);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nfunction postponeRun<T>(f: () => T, priority?: boolean): T {\n\tconst list = !priority && waitList || new Map();\n\tconst old = waitList;\n\twaitList = list;\n\ttry {\n\t\treturn f();\n\t} finally {\n\t\twaitList = old;\n\t\tif (list !== waitList) { runDeferred(list); }\n\t}\n}\nexport function postpone<T>(priority: boolean, f: () => T): T;\nexport function postpone<T>(fn: () => T, priority?: boolean): T;\nexport function postpone<T>(\n\tfn: (() => T) | boolean | undefined,\n\tpriority?: (() => T) | boolean | undefined\n): T;\nexport function postpone<T>(\n\tfn: (() => T) | boolean | undefined,\n\tpriority?: (() => T) | boolean | undefined\n): T {\n\tif (typeof fn === 'function') {\n\t\treturn postponeRun(fn, priority as boolean | undefined);\n\t}\n\tif (typeof priority !== 'function') {\n\t\tthrow new Error('fn needs to be a function');\n\t}\n\treturn postponeRun(priority, fn);\n}\n\n\nfunction wait(\n\ttarget: object | Function,\n\tprop: string | boolean | symbol,\n) {\n\tif (!waitList) { return false; }\n\tgetMapValue(waitList, target, () => new Set()).add(prop);\n\treturn true;\n}\n\n/**\n * 标记属性的修改，同时触发监听函数\n * @param target 要标记的对象\n * @param prop   要标记的属性 特别的，false 表示原型，true 表示成员\n */\nexport function markChange(\n\ttarget: object | Function,\n\tprop: string | number | boolean | symbol,\n) {\n\n\tconst indexes = getIndexes(target, prop);\n\tif (!indexes) { return; }\n\t[target, prop] = indexes;\n\tif (wait(target, prop)) {\n\t\texecWatch(target, prop, Boolean);\n\t\treturn;\n\t}\n\texecWatch(target, prop);\n}\n\n/**\n * 观察对象属性的变化\n * @param target 要观察的对象\n * @param prop   要观察的属性名 特别的，false 表示原型，true 表示成员\n * @param fn     属性改变后触发的函数\n */\nexport function watchProp(\n\ttarget: object | Function,\n\tprop: string | number | boolean | symbol,\n\tcb: () => void,\n\tdisdeferable: boolean = false,\n): () => void {\n\tif (typeof cb !== 'function') { return  () => {}; }\n\tconst indexes = getIndexes(target, prop);\n\tif (!indexes) { return () => {}; }\n\t[target, prop] = indexes;\n\n\tconst key = prop;\n\tlet map = watchList.get(target);\n\tif (!map) {\n\t\tmap = new Map();\n\t\twatchList.set(target, map);\n\t}\n\tconst list = getMapValue(map, key, () => new Set());\n\tconst item: [() => void, boolean] = [safeify(cb), disdeferable];\n\tlist.add(item);\n\tlet removed = false;\n\treturn () => {\n\t\tif (removed) { return; }\n\t\tremoved = true;\n\n\t\t// 从当前列表中移除\n\t\tlist.delete(item);\n\n\t\t// 从属性关联中删除\n\t\tif (list.size) { return; }\n\t\tif (!map) { return; }\n\t\tmap.delete(key);\n\n\t\t// 映射列表中删除\n\t\tif (map.size) { return; }\n\t\twatchList.delete(target);\n\t};\n\n}\n","import { safeify } from './utils';\nimport { observe, watchProp, ReadMap, ObserveOptions } from './mark';\n\nexport interface ExecResult<T> {\n\tresult: T;\n\tstop(): void;\n}\nexport interface ExecOptions extends ObserveOptions {\n\tresultOnly?: boolean;\n\tdisdeferable?: boolean;\n}\nfunction run<T>(\n\tcb: (changed: boolean) => void,\n\tfn: (stop: () => void) => T,\n\toptions?: ExecOptions,\n): ExecResult<T> | T {\n\tcb = safeify(cb);\n\tlet cancelList: (() => void)[] | undefined;\n\tconst postpone = options?.postpone;\n\tlet end = false;\n\t/** 取消监听 */\n\tfunction cancel() {\n\t\tif (end) { return false; }\n\t\tend = true;\n\t\tif (!cancelList) { return true; }\n\t\tconst list = cancelList;\n\t\tcancelList = undefined;\n\t\tlist.forEach(f => f());\n\t\treturn true;\n\t}\n\tfunction trigger() {\n\t\tif (!cancel()) { return; }\n\t\tcb(true);\n\t};\n\tfunction run(thisRead: ReadMap) {\n\t\tif (end) { return false; }\n\t\tif (!thisRead.size) {\n\t\t\tend = true;\n\t\t\treturn cb(false);\n\t\t}\n\t\tconst list: [\n\t\t\tobject | Function,\n\t\t\tstring | boolean | symbol,\n\t\t][] = [];\n\t\tfor ( let [obj, props] of thisRead) {\n\t\t\tfor (const [p, m] of props) {\n\t\t\t\tif (m) { return cb(true); }\n\t\t\t\tlist.push([obj, p]);\n\t\t\t}\n\t\t}\n\t\tcancelList = list.map(\n\t\t\t([obj, p]) => watchProp(\n\t\t\t\tobj,\n\t\t\t\tp,\n\t\t\t\ttrigger,\n\t\t\t\toptions?.disdeferable,\n\t\t\t),\n\t\t);\n\t}\n\tfunction stop() {\n\t\tif (!cancel()) { return; }\n\t\tcb(false);\n\t};\n\tconst thisRead: ReadMap = new Map();\n\tconst result = observe(thisRead, () => fn(stop), { postpone });\n\trun(thisRead);\n\tif (options?.resultOnly) { return result; }\n\treturn { result, stop };\n}\n\n/**\n * 创建可监听执行函数\n * @param fn 要监听执行的函数\n * @param cb 当监听的值发生可能改变时触发的回调函数，单如果没有被执行的函数或抛出错误，将会在每次 fn 被执行后直接执行\n */\nexport function exec<T>(\n\tcb: (changed: boolean) => void,\n\tfn: (stop: () => void) => T,\n\toptions?: ExecOptions & {resultOnly?: false},\n): ExecResult<T>;\nexport function exec<T>(\n\tcb: (changed: boolean) => void,\n\toptions: ExecOptions & {resultOnly?: false} | undefined,\n\tfn?: (stop: () => void) => T,\n): ExecResult<T>;\n\nexport function exec<T>(\n\tcb: (changed: boolean) => void,\n\tfn: (stop: () => void) => T,\n\toptions: ExecOptions & {resultOnly: true},\n): T;\nexport function exec<T>(\n\tcb: (changed: boolean) => void,\n\toptions: ExecOptions & {resultOnly: true},\n\tfn: (stop: () => void) => T,\n): T;\n\nexport function exec<T>(\n\tcb: (changed: boolean) => void,\n\tfn: (stop: () => void) => T,\n\toptions?: ExecOptions,\n): ExecResult<T> | T;\nexport function exec<T>(\n\tcb: (changed: boolean) => void,\n\toptions: ExecOptions | undefined,\n\tfn: (stop: () => void) => T,\n): ExecResult<T> | T;\n\nexport function exec<T>(\n\tcb: (changed: boolean) => void,\n\tfn: ((stop: () => void) => T) | ExecOptions | undefined,\n\toptions?: ((stop: () => void) => T) | ExecOptions | undefined,\n): ExecResult<T> | T  {\n\tif (typeof cb !== 'function') {\n\t\tthrow new Error('cb needs to be a function');\n\t}\n\tif (typeof fn === 'function') {\n\t\treturn run(cb, fn, options as ExecOptions | undefined);\n\t}\n\tif (typeof options !== 'function') {\n\t\tthrow new Error('fn needs to be a function');\n\t}\n\treturn run(cb, options, fn);\n}\n","import { safeify } from './utils';\nimport { observe, watchProp, ReadMap, ObserveOptions } from './mark';\n\nexport interface Monitored<T, P extends any[] = []> {\n\t(...p: P): T;\n\tstop(): void;\n}\nexport interface MonitorOptions extends ObserveOptions {\n\tdisdeferable?: boolean;\n}\n/**\n * 创建可监听执行函数\n * @param fn 要监听执行的函数\n * @param cb 当监听的值发生可能改变时触发的回调函数，单如果没有被执行的函数或抛出错误，将会在每次 fn 被执行后直接执行\n */\nfunction create<T, P extends any[] = []>(\n\tcb: (changed: boolean) => void,\n\tfn: (...p: P) => T,\n\toptions?: MonitorOptions,\n): Monitored<T, P> {\n\tcb = safeify(cb);\n\tlet cancelList: (() => void)[] | undefined;\n\t/** 取消监听 */\n\tfunction cancel() {\n\t\tif (!cancelList) { return false; }\n\t\tconst list = cancelList;\n\t\tcancelList = undefined;\n\t\tlist.forEach(f => f());\n\t\treturn true;\n\t}\n\tfunction trigger() {\n\t\tif (!cancel()) { return; }\n\t\tcb(true);\n\t};\n\tfunction run(thisRead: ReadMap) {\n\t\tif (!thisRead.size) {\n\t\t\treturn cb(false);\n\t\t}\n\t\tconst list: [\n\t\t\tobject | Function,\n\t\t\tstring | boolean | symbol,\n\t\t][] = [];\n\t\tfor ( let [obj, props] of thisRead) {\n\t\t\tfor (const [p, m] of props) {\n\t\t\t\tif (m) { return cb(true); }\n\t\t\t\tlist.push([obj, p]);\n\t\t\t}\n\t\t}\n\t\tcancelList = list.map(\n\t\t\t([obj, p]) => watchProp(\n\t\t\t\tobj,\n\t\t\t\tp,\n\t\t\t\ttrigger,\n\t\t\t\toptions?.disdeferable,\n\t\t\t),\n\t\t);\n\t}\n\tfunction exec(...p: P) {\n\t\tcancel();\n\t\tconst thisRead: ReadMap = new Map();\n\t\tconst result = observe(thisRead, () => fn(...p), options);\n\t\trun(thisRead);\n\t\treturn result;\n\t}\n\texec.stop = () => {\n\t\tif (!cancel()) { return; }\n\t\tcb(false);\n\t};\n\treturn exec;\n}\n\n/**\n * 创建可监听执行函数\n * @param fn 要监听执行的函数\n * @param cb 当监听的值发生可能改变时触发的回调函数，单如果没有被执行的函数或抛出错误，将会在每次 fn 被执行后直接执行\n */\nexport function monitor<T, P extends any[] = []>(\n\tcb: (changed: boolean) => void,\n\tfn: (...p: P) => T,\n\toptions?: MonitorOptions,\n): Monitored<T, P>\nexport function monitor<T, P extends any[] = []>(\n\tcb: (changed: boolean) => void,\n\toptions: MonitorOptions | undefined,\n\tfn: (...p: P) => T,\n): Monitored<T, P>;\nexport function monitor<T, P extends any[] = []>(\n\tcb: (changed: boolean) => void,\n\tfn: ((...p: P) => T) | MonitorOptions | undefined,\n\toptions?: ((...p: P) => T) | MonitorOptions,\n): Monitored<T, P>;\nexport function monitor<T, P extends any[] = []>(\n\tcb: (changed: boolean) => void,\n\tfn: ((...p: P) => T) | MonitorOptions | undefined,\n\toptions?: ((...p: P) => T) | MonitorOptions,\n): Monitored<T, P> {\n\tif (typeof fn === 'function') {\n\t\treturn create(cb, fn, options as MonitorOptions | undefined);\n\t}\n\tif (typeof options !== 'function') {\n\t\tthrow new Error('fn needs to be a function');\n\t}\n\treturn create(cb, options, fn);\n}\n","import { safeCall } from './utils';\nimport { markRead, markChange, watchProp } from './mark';\nimport { monitor } from './monitor';\n\n/** 取消监听的方法 */\nexport interface CancelWatch {\n\t(): void;\n}\n/** 监听函数 */\nexport interface WatchCallback<T, V extends Value<T> = Value<T>> {\n\t(v: V, stopped: boolean): void;\n}\n/** 可监听值 */\nexport interface Value<T> {\n\t(): T;\n\t(v: T, mark?: boolean): T;\n\tvalue: T;\n\twatch(cb: WatchCallback<T, this>, disdeferable?: boolean): CancelWatch;\n\tstop(): void;\n\ttoString(...p: T extends {toString(...p: infer P): string} ? P : any): string;\n\tvalueOf(): T extends {valueOf(): infer R} ? R : T;\n}\nconst values = new WeakSet<Value<any>>();\nexport function isValue(x: any): x is Value<any> {\n\treturn values.has(x);\n}\n/** 触发监听 */\ninterface Trigger {\n\t(): void;\n\t/** 是否存在监听函数 */\n\thas(): boolean;\n\t/** 停止监听 */\n\tstop(): void;\n}\n\n\nfunction valueOf<T>(this: Value<T>) {\n\tconst value = this();\n\tif (value === undefined) { return value; }\n\tif (value === null) { return value; }\n\treturn (value as any).valueOf();\n}\nfunction toString<T>(this: Value<T>, ...p: any) {\n\tconst value = this();\n\tif (value === undefined) { return String(value); }\n\tif (value === null) { return String(value); }\n\tif (typeof (value as any).toString === 'function') {\n\t\treturn (value as any).toString(...p);\n\t}\n\treturn String(value);\n}\nfunction toPrimitive<T>(this: Value<T>, hint?: 'string' | 'number' | 'default') {\n\tconst value = this();\n\tif (value === undefined) { return String(value); }\n\tif (value === null) { return String(value); }\n\tif (typeof (value as any)[Symbol.toPrimitive] === 'function') {\n\t\treturn (value as any)[Symbol.toPrimitive](hint);\n\t}\n\tif (hint === 'string') {\n\t\treturn String(value);\n\t}\n\tif (hint === 'number') {\n\t\treturn Number(value);\n\t}\n\treturn value;\n}\n\nfunction createValue<T, V extends Value<T> = Value<T>>(\n\trecover: () => T,\n\tsetValue?: (value: T, markChange: () => void) => void,\n\tstop: () => void = () => {},\n\tchange: () => void = () => {},\n): {value: V, trigger: Trigger} {\n\tfunction set(v: T, marked = false) {\n\t\tif (!setValue) { return; }\n\t\ttry {\n\t\t\tsetValue(v, () => { marked = true; });\n\t\t} finally {\n\t\t\tif (marked) {\n\t\t\t\ttrigger();\n\t\t\t}\n\t\t}\n\t}\n\tfunction get() {\n\t\tmarkRead(value, 'value');\n\t\treturn recover();\n\t}\n\tconst value: V = ((...v: [T] | [T, boolean] | []): T => {\n\t\tif (v.length) {\n\t\t\tset(v[0], v[1]);\n\t\t\treturn v[0];\n\t\t}\n\t\treturn get();\n\t}) as V;\n\tReflect.defineProperty(value, 'value', {\n\t\tget,\n\t\tset,\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t});\n\tReflect.defineProperty(value, 'valueOf', {\n\t\tvalue: valueOf,\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t});\n\tReflect.defineProperty(value, 'toString', {\n\t\tvalue: toString,\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t});\n\n\tReflect.defineProperty(value, Symbol.toPrimitive, {\n\t\tvalue: toPrimitive,\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t});\n\n\tlet stopList: Set<() => void> | undefined = new Set();\n\tfunction watch(\n\t\tcb: WatchCallback<T, V>,\n\t\tdisdeferable?: boolean,\n\t): () => void {\n\t\tif (!stopList) { return () => {}; }\n\t\tconst cancel = watchProp(\n\t\t\tvalue,\n\t\t\t'value',\n\t\t\t() => cb(value, false),\n\t\t\tdisdeferable,\n\t\t);\n\t\tlet cancelled = false;\n\t\tconst stop = () => {\n\t\t\tif (cancelled) { return; }\n\t\t\tcancelled = true;\n\t\t\tif (stopList) { stopList.delete(stop); }\n\t\t\tcancel();\n\t\t\tsafeCall(() => cb(value, true));\n\t\t};\n\t\tstopList.add(stop);\n\t\tchange();\n\t\treturn () => {\n\t\t\tif (cancelled) { return; }\n\t\t\tcancelled = true;\n\t\t\tif (stopList) { stopList.delete(stop); }\n\t\t\tcancel();\n\t\t\tchange();\n\t\t};\n\t}\n\tReflect.defineProperty(value, 'watch', {\n\t\tget() { return watch; },\n\t\tset() {},\n\t\tconfigurable: true,\n\t});\n\tconst trigger = (() => markChange(value, 'value')) as Trigger;\n\ttrigger.has = () => Boolean(stopList?.size);\n\ttrigger.stop = () => {\n\t\tif (!stopList) { return; }\n\t\tconst list = stopList;\n\t\tstopList = undefined;\n\t\tfor (const stop of [...list]) {\n\t\t\tstop();\n\t\t}\n\t};\n\tvalues.add(value);\n\tlet stopped = false;\n\tvalue.stop = () => {\n\t\tif (stopped) { return; }\n\t\tstopped = true;\n\t\tstop();\n\t\ttrigger.stop();\n\n\t};\n\treturn {value, trigger};\n}\n/**\n * 创建引用值\n * @param value 初始值\n * @param options 选项\n */\nexport function value<T>(def: T): Value<T> {\n\tlet source: T;\n\tlet proxyValue: T;\n\tconst { value } = createValue<T>(\n\t\t() => proxyValue,\n\t\t(v, mark) => {\n\t\t\tif (v === source) { return; }\n\t\t\tsource = v;\n\t\t\tproxyValue = source;\n\t\t\tmark();\n\t\t},\n\t);\n\tvalue(def);\n\treturn value;\n}\n\nexport interface ComputedOptions {\n\tpostpone?: boolean | 'priority';\n\tdeferable?: boolean;\n}\n/**\n * 创建计算值\n * @param getter 取值方法\n * @param options 选项\n */\nexport function computed<T>(\n\tgetter: () => T,\n\toptions?: ComputedOptions,\n): Value<T>;\n/**\n * 创建可赋值计算值\n * @param getter 取值方法\n * @param setter 复制方法\n * @param options 选项\n */\nexport function computed<T>(\n\tgetter: () => T,\n\tsetter: (value: T) => void,\n\toptions?: ComputedOptions,\n): Value<T>;\nexport function computed<T>(\n\tgetter: () => T,\n\tsetter?: ((value: T) => void) | ComputedOptions,\n\toptions?: ComputedOptions,\n): Value<T>;\nexport function computed<T>(\n\tgetter: () => T,\n\tsetter?: ((value: T) => void) | ComputedOptions,\n\toptions?: ComputedOptions,\n): Value<T> {\n\tif (typeof setter !== 'function') {\n\t\toptions = setter;\n\t\tsetter = undefined;\n\t}\n\tconst setValue = setter;\n\tconst postpone = options?.postpone;\n\tconst deferable = options?.deferable;\n\tlet source: T;\n\tlet proxyValue: T;\n\tlet stopped = false;\n\tlet computed = false;\n\tlet trigger: Trigger | undefined;\n\tconst executable = monitor(changed => {\n\t\tcomputed = !changed;\n\t\tif (changed  && trigger) {\n\t\t\ttrigger();\n\t\t}\n\t}, getter, { postpone, disdeferable: !deferable });\n\tfunction run() {\n\t\tcomputed = true;\n\t\ttry {\n\t\t\tsource = executable();\n\t\t\tproxyValue = source;\n\t\t\treturn proxyValue;\n\t\t} catch(e) {\n\t\t\tif (!stopped) {\n\t\t\t\tcomputed = false;\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}\n\tlet value: Value<T>;\n\t({value, trigger} = createValue<T, Value<T>>(\n\t\t() => computed || stopped ? proxyValue : run(),\n\t\tsetValue && (v => setValue(v)),\n\t\t() => {\n\t\t\tif (stopped) { return; }\n\t\t\tstopped = true;\n\t\t\tif (computed) { return; }\n\t\t\trun();\n\t\t},\n\t));\n\treturn value;\n\n}\n","import {\n\tValue,\n\tcomputed,\n\tisValue,\n} from './value';\n\nexport type DeValue<T> = T extends Value<infer V> ? V : T;\nexport type EnValue<T> = Value<DeValue<T>>;\n\nexport interface Valueify<T> {\n\t<K extends keyof T>(\n\t\tkey: K,\n\t\tdef?: Value<DeValue<T[K]> | undefined>,\n\t\tset?: (value: DeValue<T[K]>, setted: boolean) => void\n\t): Value<DeValue<T[K]> | undefined>\n}\n\nfunction createValue<T, K extends keyof T>(\n\tprops: T,\n\tkey: K,\n\tdef?: Value<DeValue<T[K]> | undefined>,\n\tset?: (value: DeValue<T[K]>, setted: boolean) => void,\n): Value<DeValue<T[K]> | undefined> {\n\tfunction setValue(value: DeValue<T[K]>, setted: boolean): void {\n\t\tif (!set) { return; }\n\t\tset(value, setted);\n\t}\n\treturn computed(() => {\n\t\tconst p = props[key];\n\t\tif (p === undefined && def) { return def(); }\n\t\treturn isValue(p) ? p() : p;\n\t}, v => {\n\t\tconst p = props[key];\n\t\tif (isValue(p)) {\n\t\t\tp(v);\n\t\t\tsetValue(v, true);\n\t\t\treturn;\n\t\t}\n\t\tif (p === undefined && def) {\n\t\t\tdef(v);\n\t\t\tsetValue(v, false);\n\t\t\treturn;\n\t\t}\n\t\tsetValue(v, false);\n\t});\n}\nexport function valueify<T extends object>(props: T): Valueify<T>;\nexport function valueify<T extends object, K extends keyof T>(\n\tprops: T,\n\tkey: K,\n\tdef?: Value<DeValue<T[K]> | undefined>,\n\tset?: (value: DeValue<T[K]>, setted: boolean) => void,\n): Value<DeValue<T[K]> | undefined>;\nexport function valueify<T extends object, K extends keyof T>(\n\tprops: T,\n\tkey: K[],\n\tdef?: (key: K) => Value<DeValue<T[K]> | undefined>,\n\tset?: (value: DeValue<T[K]>, setted: boolean, key: K) => void,\n): {[k in K]: Value<DeValue<T[k]> | undefined>};\nexport function valueify<T extends object, K extends keyof T>(\n\tprops: T,\n\tkey?: K | K[],\n\tdef?: (key: K) => Value<DeValue<T[K]> | undefined>,\n\tset?: (value: DeValue<T[K]>, setted: boolean, key?: K) => void\n): Valueify<T>\n| Value<DeValue<T[K]> | undefined>\n| {[k in K]: Value<DeValue<T[k]> | undefined>} {\n\tif (!key) {\n\t\treturn (k, d, s) => createValue(props, k, d, s);\n\t}\n\tif (!Array.isArray(key)) {\n\t\treturn createValue(\n\t\t\tprops,\n\t\t\tkey,\n\t\t\tdef as Value<DeValue<T[K]> | undefined>,\n\t\t\tset,\n\t\t);\n\t}\n\tconst r = Object.create(null);\n\tfor (const k of key) {\n\t\tconst value = createValue(\n\t\t\tprops,\n\t\t\tk,\n\t\t\tdef && def(k),\n\t\t\tset && ((v, s) => set!(v, s, k))\n\t\t);\n\t\tReflect.defineProperty(props, k, {\n\t\t\tget() { return value(); },\n\t\t\tset(v) { value.value = v; },\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t});\n\t}\n\treturn r;\n}\nexport function mixValue<T extends object, K extends keyof T>(\n\tsource: T,\n\tprops = Reflect.ownKeys(source) as K[] | {\n\t\t[k in K]?: Value<DeValue<T[k]> | undefined>;\n\t},\n\tset?: (value: DeValue<T[K]>, setted: boolean, key?: K) => void\n): { [k in keyof T]: k extends K ? DeValue<T[k]> : T[k]; } {\n\tconst p = Object.create(source);\n\tif (Array.isArray(props)) {\n\t\tfor (const key of props) {\n\t\t\tconst value = createValue(\n\t\t\t\tsource,\n\t\t\t\tkey,\n\t\t\t\tundefined,\n\t\t\t\tset && ((v, s) => set!(v, s, key))\n\t\t\t);\n\t\t\tReflect.defineProperty(p, key, {\n\t\t\t\tget() { return value(); },\n\t\t\t\tset(v) { value.value = v; },\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t});\n\t\t}\n\t\treturn p;\n\t}\n\tconst keys = Reflect.ownKeys(props) as K[];\n\tfor (const key of keys) {\n\t\tconst value = createValue(\n\t\t\tsource,\n\t\t\tkey,\n\t\t\tprops[key],\n\t\t\tset && ((v, s) => set!(v, s, key))\n\t\t);\n\t\tReflect.defineProperty(p, key, {\n\t\t\tget() { return value(); },\n\t\t\tset(v) { value.value = v; },\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t});\n\t}\n\treturn p;\n}\n\nexport interface AsValue<T> {\n\t<K extends keyof T>(key: K): EnValue<T[K]>\n}\n\nfunction createAsValue<T, K extends keyof T>(\n\tprops: T,\n\tkey: K,\n): EnValue<T[K]> {\n\treturn computed(() => {\n\t\tconst p = props[key];\n\t\treturn isValue(p) ? p() : p;\n\t}, v => {\n\t\tconst p = props[key];\n\t\tif (isValue(p)) {\n\t\t\tp(v);\n\t\t} else {\n\t\t\tprops[key] = v;\n\t\t}\n\t});\n}\nexport function asValue<T>(props: T): AsValue<T>;\nexport function asValue<T, K extends keyof T>(\n\tprops: T,\n\tkey: K,\n): EnValue<T[K]>;\nexport function asValue<T, K extends keyof T>(\n\tprops: T,\n\tkey?: K,\n): AsValue<T> | EnValue<T[K]> {\n\tif (arguments.length >= 2) {\n\t\treturn createAsValue(props, key!);\n\t}\n\treturn k => createAsValue(props, k);\n}\n","\nimport {\n\tValue,\n\tWatchCallback,\n} from './value';\n\nexport function merge<T, V extends Value<T> = Value<T>>(\n\tcb: WatchCallback<T, V>\n): WatchCallback<T, V> {\n\tlet oldValue: any;\n\tlet ran = false;\n\treturn (v, stopped) => {\n\t\tif (stopped) { return cb(v, stopped); }\n\t\tconst newValue = v();\n\t\tif (newValue === oldValue && ran) { return; }\n\t\tran = true;\n\t\toldValue = newValue;\n\t\tcb(v, stopped);\n\t};\n}\n","import { markChange, markRead } from './mark';\nexport function defineProperty<\n\tT extends object,\n\tK extends keyof T,\n\tV extends T[K]\n>(obj: T, key: K, val: V): boolean {\n\treturn Reflect.defineProperty(obj, key, {\n\t\tget() {\n\t\t\tmarkRead(obj, key);\n\t\t\treturn val;\n\t\t},\n\t\tset(v) {\n\t\t\tif (v === val) { return; }\n\t\t\tval = v;\n\t\t\tmarkChange(obj, key);\n\t\t},\n\t\tconfigurable: true,\n\t\tenumerable: true,\n\t});\n}\nexport function createObject<T extends object>(\n\tkeys: (keyof T)[],\n\tbase: T | null = {} as T,\n\tcreate?: boolean\n): T {\n\tconst obj = create || base === null ? Object.create(base) : base;\n\tfor (const key of keys) {\n\t\tlet val = obj[key];\n\t\tReflect.defineProperty(obj, key, {\n\t\t\tget() {\n\t\t\t\tmarkRead(obj, key);\n\t\t\t\treturn val;\n\t\t\t},\n\t\t\tset(v) {\n\t\t\t\tif (v === val) { return; }\n\t\t\t\tval = v;\n\t\t\t\tmarkChange(obj, key);\n\t\t\t},\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t});\n\t}\n\treturn obj;\n}\n\nexport function get<\n\tT extends object,\n\tK extends keyof T,\n>(obj: T, key: K): T[K] {\n\tmarkRead(obj, key);\n\treturn obj[key];\n}\n\nexport function set<\n\tT extends object,\n\tK extends keyof T,\n\tV extends T[K]\n>(obj: T, key: K, v: V): V {\n\tif (v === obj[key]) { return v; }\n\tobj[key] = v;\n\tmarkChange(obj, key);\n\treturn v;\n}\n","import { markChange, markRead } from './mark';\n\n/**\n * 判断对象是否可被代理\n */\nfunction encashable(v: any): v is object | Function {\n\treturn Boolean(v && ['object', 'function'].includes(typeof v));\n}\n\nlet getValue: any;\n/**\n * 获取被代理对象\n * @param obj  要被代理的对象\n * @param nest 递归代理的层数\n */\nexport function encase<T>(value: T, nest: number | boolean = 0): T {\n\tif (!encashable(value)) { return value; }\n\tconst original = recover(value);\n\tconst nestLayer: number = nest === true ? Infinity : nest || 0;\n\tconst proxy = new Proxy(original, {\n\t\tset(target, prop, value, receiver) {\n\t\t\tif (nest === false) {\n\t\t\t\treturn Reflect.set(target, prop, value, receiver);\n\t\t\t}\n\t\t\tconst has = Reflect.has(target, prop);\n\t\t\tconst old = Reflect.get(target, prop, receiver);\n\t\t\tconst modified =\n\t\t\t\tReflect.set(target, prop, value, encase(receiver));\n\t\t\tif (!modified) { return modified; }\n\t\t\tif (has !== Reflect.has(target, prop)) {\n\t\t\t\tmarkChange(receiver, true);\n\t\t\t}\n\t\t\tif (old !== Reflect.get(target, prop, receiver)) {\n\t\t\t\tmarkChange(receiver, prop);\n\t\t\t}\n\t\t\treturn modified;\n\t\t},\n\t\tget(target, prop, receiver) {\n\t\t\tif (getValue === proxy) {\n\t\t\t\tif (prop === '__monitorable__recover__') {\n\t\t\t\t\tgetValue = original;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nest === false) {\n\t\t\t\treturn Reflect.get(target, prop, receiver);\n\t\t\t}\n\t\t\tmarkRead(receiver, prop);\n\t\t\tconst value = Reflect.get(target, prop, encase(receiver));\n\t\t\tif (nestLayer > 0) { return encase(value, nestLayer - 1); }\n\t\t\treturn value;\n\t\t},\n\t\tsetPrototypeOf(target, proto) {\n\t\t\tif (nest === false) {\n\t\t\t\treturn Reflect.setPrototypeOf(target, proto);\n\t\t\t}\n\t\t\tconst oldProto = Reflect.getPrototypeOf(target);\n\t\t\tconst modified = Reflect.setPrototypeOf(target, proto);\n\t\t\tif (modified && oldProto !== proto) {\n\t\t\t\tmarkChange(target, false);\n\t\t\t\tmarkChange(proxy, false);\n\t\t\t}\n\t\t\treturn modified;\n\t\t},\n\t\tgetPrototypeOf(target) {\n\t\t\tif (nest === false) {\n\t\t\t\treturn Reflect.getPrototypeOf(target);\n\t\t\t}\n\t\t\tmarkRead(target, false);\n\t\t\tmarkRead(proxy, false);\n\t\t\tconst value: any = Reflect.getPrototypeOf(target);\n\t\t\tif (nestLayer > 0) {\n\t\t\t\treturn encase(value, nestLayer - 1);\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\t\tdefineProperty(target, prop, attr) {\n\t\t\tif (nest === false) {\n\t\t\t\treturn Reflect.defineProperty(target, prop, attr);\n\t\t\t}\n\t\t\tlet changed = true;\n\t\t\tif ('value' in attr) {\n\t\t\t\tconst desc =\n\t\t\t\t\tReflect.getOwnPropertyDescriptor(target, prop);\n\t\t\t\tif (\n\t\t\t\t\tdesc && 'value' in desc\n\t\t\t\t\t&& recover(attr.value) === recover(desc.value)) {\n\t\t\t\t\tchanged = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst modified = Reflect.defineProperty(target, prop, attr);\n\t\t\tif (changed && modified) {\n\t\t\t\tmarkChange(target, prop);\n\t\t\t\tmarkChange(proxy, prop);\n\t\t\t}\n\t\t\treturn modified;\n\t\t},\n\t\tgetOwnPropertyDescriptor(target, prop) {\n\t\t\tif (nest === false) {\n\t\t\t\treturn Reflect.getOwnPropertyDescriptor(target, prop);\n\t\t\t}\n\t\t\tmarkRead(target, prop);\n\t\t\tmarkRead(proxy, prop);\n\t\t\treturn Reflect.getOwnPropertyDescriptor(target, prop);\n\t\t},\n\t\tdeleteProperty(target, prop) {\n\t\t\tif (nest === false) {\n\t\t\t\treturn Reflect.deleteProperty(target, prop);\n\t\t\t}\n\t\t\tconst has = Reflect.has(target, prop);\n\t\t\tconst deleted = Reflect.deleteProperty(target, prop);\n\t\t\tif (has && !Reflect.has(target, prop)) {\n\t\t\t\tmarkChange(target, prop);\n\t\t\t\tmarkChange(target, true);\n\t\t\t\tmarkChange(proxy, prop);\n\t\t\t\tmarkChange(proxy, true);\n\t\t\t}\n\t\t\treturn deleted;\n\t\t},\n\t\townKeys(target) {\n\t\t\tif (nest === false) { return Reflect.ownKeys(target); }\n\t\t\tmarkRead(target, true);\n\t\t\tmarkRead(proxy, true);\n\t\t\treturn Reflect.ownKeys(target);\n\t\t},\n\t\thas(target, prop) {\n\t\t\tif (nest === false) { return Reflect.has(target, prop); }\n\t\t\tmarkRead(target, true);\n\t\t\tmarkRead(proxy, true);\n\t\t\treturn Reflect.has(target, prop);\n\t\t},\n\t});\n\treturn proxy;\n}\n/** 获取被代理的原始值 */\nexport function recover<T>(v: T): T {\n\tif (!v) { return v; }\n\tif (!encashable(v)) { return v; }\n\tlet value = v;\n\ttry {\n\t\tgetValue = v;\n\t\tvalue = (v as any).__monitorable__recover__;\n\t} catch {}\n\tvalue = getValue;\n\tgetValue = false;\n\tif (!value) { return v; }\n\tif (typeof value === 'object') { return value; }\n\tif (typeof value === 'function') { return value; }\n\treturn v;\n}\nexport function equal(a: any, b: any): boolean {\n\treturn recover(a) === recover(b);\n}\n"],"names":["printErrorLog","read","printError","info","console","error","setPrintError","p","undefined","encashable","v","Boolean","includes","safeify","fn","e","safeCall","getIndexes","target","prop","String","getMapValue","map","key","def","has","get","value","set","markRead","indexes","propMap","Map","observeRun","options","oldRead","postpone","observe","Error","watchList","WeakMap","execWatch","filter","watch","_watchList$get","list","t","forEach","w","waitList","postponeRun","f","priority","old","entries","_read","runDeferred","markChange","Set","add","wait","watchProp","cb","disdeferable","item","removed","delete","size","run","cancelList","end","cancel","trigger","stop","thisRead","result","obj","props","m","push","resultOnly","exec","create","monitor","values","WeakSet","isValue","x","valueOf","this","toString","toPrimitive","hint","Symbol","Number","createValue","recover","setValue","change","marked","length","Reflect","defineProperty","enumerable","configurable","stopList","cancelled","_stopList","stopped","source","proxyValue","mark","computed","getter","setter","_options","deferable","_options2","executable","changed","setted","valueify","k","d","s","Array","isArray","r","Object","mixValue","ownKeys","keys","createAsValue","asValue","arguments","merge","oldValue","ran","newValue","val","createObject","base","getValue","encase","nest","original","nestLayer","Infinity","proxy","Proxy","receiver","modified","setPrototypeOf","proto","oldProto","getPrototypeOf","attr","desc","getOwnPropertyDescriptor","deleteProperty","deleted","__monitorable__recover__","equal","a","b"],"mappings":"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"}