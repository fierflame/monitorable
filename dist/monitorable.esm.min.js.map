{"version":3,"file":"monitorable.esm.min.js","sources":["../src/utils.ts","../src/mark.ts","../src/encase.ts","../src/exec.ts","../src/executable.ts","../src/value.ts"],"sourcesContent":["\nlet printErrorLog: undefined | ((info: any) => void);\n/** 设置或移除错误打印函数 */\nexport function printError(fn?: (info: any) => void): void;\n/** 打印错误 */\nexport function printError(info: any, print: true): void;\n/** 打印错误 */\nexport function printError(info: any): void;\nexport function printError(\n\tinfo?: string | Error | ((info: any) => void),\n\tprint = false\n) {\n\tif (!print && (typeof info === 'function' || info === undefined)) {\n\t\tprintErrorLog = info;\n\t\treturn;\n\t}\n\tif (typeof printErrorLog === 'function') {\n\t\tprintErrorLog(info);\n\t\treturn;\n\t}\n\tconsole.error(info);\n}\n\n/**\n * 判断对象是否可被代理\n */\nexport function encashable(v: any): v is object | Function {\n\treturn Boolean(v && ['object', 'function'].includes(typeof v));\n}\n\n\n/** 回调函数安全化处理 */\nexport function safeify<T extends any[]>(\n\tfn: (...p: T) => void\n): (...p: T) => void {\n\treturn (...p) => {\n\t\ttry {\n\t\t\tfn(...p);\n\t\t} catch(e) {\n\t\t\tprintError(e, true);\n\t\t}\n\t};\n}\nexport function getIndexes(\n\ttarget: any,\n\tprop: string | number | symbol | boolean,\n): [object | Function, string | boolean | symbol] | undefined {\n\tif (!target) { return undefined; }\n\tif (typeof target !== 'function' && typeof target !== 'object') {\n\t\treturn undefined;\n\t}\n\tif (typeof prop === 'number') { return [target, String(prop)]; }\n\tif (typeof prop === 'symbol') { return [target, prop]; }\n\tif (typeof prop === 'string') { return [target, prop]; }\n\tif (typeof prop === 'boolean') { return [target, prop]; }\n\treturn undefined;\n}\nexport function getMapValue<K, V>(\n\tmap: Map<K, V>,\n\tkey: K,\n\tdef: () => V,\n): V;\nexport function getMapValue<K extends object, V>(\n\tmap: WeakMap<K, V>,\n\tkey: K,\n\tdef: () => V,\n): V;\nexport function getMapValue<K, V>(\n\tmap: WeakMap<K & object, V> | Map<K, V>,\n\tkey: K,\n\tdef: () => V,\n): V {\n\tif (map.has(key as any)) {\n\t\treturn map.get(key as any)!;\n\t}\n\tconst value = def();\n\tmap.set(key as any, value);\n\treturn value;\n}\n","import { safeify, getMapValue, getIndexes } from './utils';\n\nexport type ReadMap = Map<\n\tobject | Function,\n\tMap<string | boolean | symbol, boolean>\n>;\n\n/** 已被读取的 */\nlet read: ReadMap | undefined;\n\n/**\n * 标记已读状态\n * @param obj  要标记的对象\n * @param prop 要标记的属性\n */\nexport function markRead(\n\ttarget: object | Function,\n\tprop: string | number | boolean | symbol,\n) {\n\tif (!read) { return; }\n\tconst indexes = getIndexes(target, prop);\n\tif (!indexes) { return; }\n\t[target, prop] = indexes;\n\tconst propMap = getMapValue(read, target, () => new Map())\n\tif (propMap.has(prop)) { return; }\n\tpropMap.set(prop, false);\n}\nexport interface ObserveOptions {\n\tpostpone?: boolean | 'priority';\n}\n/**\n * 监听函数的执行，并将执行过程中读取的对象值设置到 map 中\n * @param fn 要执行的含糊\n * @param map 用于存储被读取对象的 map\n */\nexport function observe<T>(\n\tmap: ReadMap,\n\tfn: () => T,\n\toptions?: ObserveOptions,\n): T {\n\tconst oldRead = read;\n\tread = map;\n\ttry {\n\t\tif (!options?.postpone) { return fn(); }\n\t\treturn postpone(fn, options.postpone === 'priority');\n\t} finally {\n\t\tread = oldRead;\n\t}\n}\n\n\nconst watchList = new WeakMap<\n\tobject | Function,\n\tMap<string | boolean | symbol, Set<() => void>>\n>();\n\nfunction execWatch(\n\ttarget: object | Function,\n\tprop: string | boolean | symbol,\n) {\n\tconst watch = watchList.get(target)?.get(prop);\n\tif (!watch) { return; }\n\t[...watch].forEach(w => w());\n}\n\ntype MarkMap = Map<\n\tobject | Function,\n\tSet<string | boolean | symbol>\n>;\nlet waitList: MarkMap | undefined;\n\nfunction run(list: MarkMap) {\n\tfor (const [target, set] of list.entries()) {\n\t\tconst propMap = read?.get(target);\n\t\tfor (const prop of set) {\n\t\t\texecWatch(target, prop);\n\t\t\tif (propMap?.has(prop)) {\n\t\t\t\tpropMap.set(prop, true);\n\t\t\t}\n\t\t}\n\t}\n}\nexport function postpone<T>(f: () => T, priority?: boolean): T {\n\tconst list = !priority && waitList || new Map();\n\tconst old = waitList;\n\twaitList = list;\n\ttry {\n\t\treturn f();\n\t} finally {\n\t\twaitList = old;\n\t\tif (list !== waitList) { run(list); }\n\t}\n}\n\nfunction wait(\n\ttarget: object | Function,\n\tprop: string | boolean | symbol,\n) {\n\tif (!waitList) { return false; }\n\tgetMapValue(waitList, target, () => new Set()).add(prop);\n\treturn true;\n}\n\n/**\n * 标记属性的修改，同时触发监听函数\n * @param target 要标记的对象\n * @param prop   要标记的属性 特别的，false 表示原型，true 表示成员\n */\nexport function markChange(\n\ttarget: object | Function,\n\tprop: string | number | boolean | symbol,\n) {\n\n\tconst indexes = getIndexes(target, prop);\n\tif (!indexes) { return; }\n\t[target, prop] = indexes;\n\tif (wait(target, prop)) { return; }\n\texecWatch(target, prop);\n}\n\n/**\n * 观察对象属性的变化\n * @param target 要观察的对象\n * @param prop   要观察的属性名 特别的，false 表示原型，true 表示成员\n * @param fn     属性改变后触发的函数\n */\nexport function watchProp(\n\ttarget: object | Function,\n\tprop: string | number | boolean | symbol,\n\tcb: () => void,\n): () => void {\n\tif (typeof cb !== 'function') { return  () => {}; }\n\tconst indexes = getIndexes(target, prop);\n\tif (!indexes) { return () => {}; }\n\t[target, prop] = indexes;\n\n\tconst key = prop;\n\tlet map = watchList.get(target);\n\tif (!map) {\n\t\tmap = new Map();\n\t\twatchList.set(target, map);\n\t}\n\tconst list = getMapValue(map, key, () => new Set());\n\tcb = safeify(cb);\n\tlist.add(cb);\n\tlet removed = false;\n\treturn () => {\n\t\tif (removed) { return; }\n\t\tremoved = true;\n\n\t\t// 从当前列表中移除\n\t\tlist.delete(cb);\n\n\t\t// 从属性关联中删除\n\t\tif (list.size) { return; }\n\t\tif (!map) { return; }\n\t\tmap.delete(key);\n\n\t\t// 映射列表中删除\n\t\tif (map.size) { return; }\n\t\twatchList.delete(target);\n\t};\n\n}\n","import { markChange, markRead } from './mark';\n\n/**\n * 判断对象是否可被代理\n */\nfunction encashable(v: any): v is object | Function {\n\treturn Boolean(v && ['object', 'function'].includes(typeof v));\n}\n\nlet getValue: any;\n/**\n * 获取被代理对象\n * @param obj  要被代理的对象\n * @param nest 递归代理的层数\n */\nexport function encase<T>(value: T, nest: number | boolean = 0): T {\n\tif (!encashable(value)) { return value; }\n\tconst original = recover(value);\n\tconst nestLayer: number = nest === true ? Infinity : nest || 0;\n\tconst proxy = new Proxy(original, {\n\t\tset(target, prop, value, receiver) {\n\t\t\tif (nest === false) {\n\t\t\t\treturn Reflect.set(target, prop, value, receiver);\n\t\t\t}\n\t\t\tconst has = Reflect.has(target, prop);\n\t\t\tconst modified =\n\t\t\t\tReflect.set(target, prop, value, encase(receiver));\n\t\t\tif (!modified) { return modified; }\n\t\t\tif (has !== Reflect.has(target, prop)) {\n\t\t\t\tmarkChange(target, true);\n\t\t\t}\n\t\t\treturn modified;\n\t\t},\n\t\tget(target, prop, receiver) {\n\t\t\tif (getValue === proxy) {\n\t\t\t\tif (prop === '__monitorable__recover__') {\n\t\t\t\t\tgetValue = original;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nest === false) {\n\t\t\t\treturn Reflect.get(target, prop, receiver);\n\t\t\t}\n\t\t\tmarkRead(target, prop);\n\t\t\tconst value = Reflect.get(target, prop, encase(receiver));\n\t\t\tif (nestLayer > 0) { return encase(value, nestLayer - 1); }\n\t\t\treturn value;\n\t\t},\n\t\tsetPrototypeOf(target, proto) {\n\t\t\tif (nest === false) {\n\t\t\t\treturn Reflect.setPrototypeOf(target, proto);\n\t\t\t}\n\t\t\tconst oldProto = Reflect.getPrototypeOf(target);\n\t\t\tconst modified = Reflect.setPrototypeOf(target, proto);\n\t\t\tif (modified && oldProto !== proto) {\n\t\t\t\tmarkChange(target, false);\n\t\t\t}\n\t\t\treturn modified;\n\t\t},\n\t\tgetPrototypeOf(target) {\n\t\t\tif (nest === false) {\n\t\t\t\treturn Reflect.getPrototypeOf(target);\n\t\t\t}\n\t\t\tmarkRead(target, false);\n\t\t\tconst value: any = Reflect.getPrototypeOf(target);\n\t\t\tif (nestLayer > 0) {\n\t\t\t\treturn encase(value, nestLayer - 1);\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\t\tdefineProperty(target, prop, attr) {\n\t\t\tif (nest === false) {\n\t\t\t\treturn Reflect.defineProperty(target, prop, attr);\n\t\t\t}\n\t\t\tlet changed = true;\n\t\t\tif ('value' in attr) {\n\t\t\t\tconst desc =\n\t\t\t\t\tReflect.getOwnPropertyDescriptor(target, prop);\n\t\t\t\tif (\n\t\t\t\t\tdesc && 'value' in desc\n\t\t\t\t\t&& recover(attr.value) === recover(desc.value)) {\n\t\t\t\t\tchanged = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst modified = Reflect.defineProperty(target, prop, attr);\n\t\t\tif (changed && modified) {\n\t\t\t\tmarkChange(target, prop);\n\t\t\t}\n\t\t\treturn modified;\n\t\t},\n\t\tgetOwnPropertyDescriptor(target, prop) {\n\t\t\tif (nest === false) {\n\t\t\t\treturn Reflect.getOwnPropertyDescriptor(target, prop);\n\t\t\t}\n\t\t\tmarkRead(target, prop);\n\t\t\treturn Reflect.getOwnPropertyDescriptor(target, prop);\n\t\t},\n\t\tdeleteProperty(target, prop) {\n\t\t\tif (nest === false) {\n\t\t\t\treturn Reflect.deleteProperty(target, prop);\n\t\t\t}\n\t\t\tconst has = Reflect.has(target, prop);\n\t\t\tconst deleted = Reflect.deleteProperty(target, prop);\n\t\t\tif (has && !Reflect.has(target, prop)) {\n\t\t\t\tmarkChange(target, prop);\n\t\t\t\tmarkChange(target, true);\n\t\t\t}\n\t\t\treturn deleted;\n\t\t},\n\t\townKeys(target) {\n\t\t\tif (nest === false) { return Reflect.ownKeys(target); }\n\t\t\tmarkRead(target, true);\n\t\t\treturn Reflect.ownKeys(target);\n\t\t},\n\t\thas(target, prop) {\n\t\t\tif (nest === false) { return Reflect.has(target, prop); }\n\t\t\tmarkRead(target, true);\n\t\t\treturn Reflect.has(target, prop);\n\t\t},\n\t});\n\treturn proxy;\n}\n/** 获取被代理的原始值 */\nexport function recover<T>(v: T): T {\n\tif (!v) { return v; }\n\tif (!encashable(v)) { return v; }\n\tlet value = v;\n\ttry {\n\t\tgetValue = v;\n\t\tvalue = (v as any).__monitorable__recover__;\n\t} catch {}\n\tvalue = getValue;\n\tgetValue = false;\n\tif (!value) { return v; }\n\tif (typeof value === 'object') { return value; }\n\tif (typeof value === 'function') { return value; }\n\treturn v;\n}\nexport function equal(a: any, b: any): boolean {\n\treturn recover(a) === recover(b);\n}\n","import { safeify } from './utils';\nimport { observe, watchProp, ReadMap, ObserveOptions } from './mark';\nimport { recover } from './encase';\n\nexport interface ExecResult<T> {\n\tresult: T;\n\tstop(): void;\n}\nexport interface ExecOptions extends ObserveOptions {\n\tresultOnly?: boolean;\n}\n/**\n * 创建可监听执行函数\n * @param fn 要监听执行的函数\n * @param cb 当监听的值发生可能改变时触发的回调函数，单如果没有被执行的函数或抛出错误，将会在每次 fn 被执行后直接执行\n */\nexport function exec<T>(\n\tcb: (changed: boolean) => void,\n\tfn: () => T,\n\toptions?: ExecOptions & {resultOnly?: false},\n): ExecResult<T>;\nexport function exec<T>(\n\tcb: (changed: boolean) => void,\n\tfn: () => T,\n\toptions: ExecOptions & {resultOnly: true},\n): T;\nexport function exec<T>(\n\tcb: (changed: boolean) => void,\n\tfn: () => T,\n\toptions?: ExecOptions,\n): ExecResult<T> | T;\nexport function exec<T>(\n\tcb: (changed: boolean) => void,\n\tfn: () => T,\n\toptions?: ExecOptions,\n): ExecResult<T> | T {\n\tcb = safeify(cb);\n\tlet cancelList: (() => void)[] | undefined;\n\tconst postpone = options?.postpone;\n\t/** 取消监听 */\n\tfunction cancel() {\n\t\tif (!cancelList) { return false; }\n\t\tconst list = cancelList;\n\t\tcancelList = undefined;\n\t\tlist.forEach(f => f());\n\t\treturn true;\n\t}\n\tfunction trigger() {\n\t\tif (!cancel()) { return; }\n\t\tcb(true);\n\t};\n\tfunction run(thisRead: ReadMap) {\n\t\tif (!thisRead.size) {\n\t\t\treturn cb(false);\n\t\t}\n\t\tconst list: [\n\t\t\tobject | Function,\n\t\t\tstring | boolean | symbol,\n\t\t][] = [];\n\t\tfor ( let [obj, props] of thisRead) {\n\t\t\tfor (const [p, m] of props) {\n\t\t\t\tif (m) { return cb(true); }\n\t\t\t\tlist.push([obj, p]);\n\t\t\t}\n\t\t}\n\t\tcancelList = list.map(\n\t\t\t([obj, p]) => watchProp(recover(obj), p, trigger),\n\t\t)\n\t}\n\tconst thisRead: ReadMap = new Map();\n\tconst result = observe(thisRead, fn, { postpone });\n\trun(thisRead);\n\tif (options?.resultOnly) { return result; }\n\treturn {\n\t\tresult,\n\t\tstop() {\n\t\t\tif (!cancel()) { return; }\n\t\t\tcb(false);\n\t\t}\n\t}\n}\n","import { safeify } from './utils';\nimport { observe, watchProp, ReadMap, ObserveOptions } from './mark';\nimport { recover } from './encase';\n\nexport interface Executable<T> {\n\t(): T;\n\tstop(): void;\n}\nexport interface ExecutableOptions extends ObserveOptions {}\n/**\n * 创建可监听执行函数\n * @param fn 要监听执行的函数\n * @param cb 当监听的值发生可能改变时触发的回调函数，单如果没有被执行的函数或抛出错误，将会在每次 fn 被执行后直接执行\n */\nexport function createExecutable<T>(\n\tcb: (changed: boolean) => void,\n\tfn: () => T,\n\toptions?: ExecutableOptions,\n): Executable<T> {\n\tcb = safeify(cb);\n\tlet cancelList: (() => void)[] | undefined;\n\t/** 取消监听 */\n\tfunction cancel() {\n\t\tif (!cancelList) { return false; }\n\t\tconst list = cancelList;\n\t\tcancelList = undefined;\n\t\tlist.forEach(f => f());\n\t\treturn true;\n\t}\n\tfunction trigger() {\n\t\tif (!cancel()) { return; }\n\t\tcb(true);\n\t};\n\tfunction run(thisRead: ReadMap) {\n\t\tif (!thisRead.size) {\n\t\t\treturn cb(false);\n\t\t}\n\t\tconst list: [\n\t\t\tobject | Function,\n\t\t\tstring | boolean | symbol,\n\t\t][] = [];\n\t\tfor ( let [obj, props] of thisRead) {\n\t\t\tfor (const [p, m] of props) {\n\t\t\t\tif (m) { return cb(true); }\n\t\t\t\tlist.push([obj, p]);\n\t\t\t}\n\t\t}\n\t\tcancelList = list.map(\n\t\t\t([obj, p]) => watchProp(recover(obj), p, trigger),\n\t\t)\n\t}\n\tfunction exec() {\n\t\tcancel();\n\t\tconst thisRead: ReadMap = new Map();\n\t\tconst result = observe(thisRead, fn, options);\n\t\trun(thisRead);\n\t\treturn result;\n\t}\n\texec.stop = () => {\n\t\tif (!cancel()) { return; }\n\t\tcb(false);\n\t};\n\treturn exec;\n}\n","import { safeify } from './utils';\nimport { markRead, markChange } from './mark';\nimport { recover, encase } from './encase';\nimport { createExecutable } from './executable';\n\n/** 取消监听的方法 */\nexport interface CancelWatch {\n\t(): void;\n}\n/** 可监听值 */\nexport interface Value<T> {\n\t(): T;\n\t(v: T, mark?: boolean): T;\n\tvalue: T;\n\twatch(cb: WatchCallback<T, this>): CancelWatch;\n\tstop(): void;\n\ttoString(...p: T extends {toString(...p: infer P): string} ? P : any): string;\n\tvalueOf(): T extends {valueOf(): infer R} ? R : T;\n}\n/** 监听函数 */\nexport interface WatchCallback<T, V extends Value<T> = Value<T>> {\n\t(v: V, stopped: boolean): void;\n}\nconst values = new WeakSet<Value<any>>();\nexport function isValue(x: any): x is Value<any> {\n\treturn values.has(x);\n}\n/** 触发监听 */\ninterface Trigger {\n\t(): void;\n\t/** 是否存在监听函数 */\n\thas(): boolean;\n\t/** 停止监听 */\n\tstop(): void;\n}\nexport interface Options {\n\tproxy?: boolean;\n}\n\n\nfunction valueOf<T>(this: Value<T>) {\n\tconst value = this();\n\tif (value === undefined) { return value; }\n\tif (value === null) { return value; }\n\treturn (value as any).valueOf();\n}\nfunction toString<T>(this: Value<T>, ...p: any) {\n\tconst value = this();\n\tif (value === undefined) { return String(value); }\n\tif (value === null) { return String(value); }\n\tif (typeof (value as any).toString === 'function') {\n\t\treturn (value as any).toString(...p);\n\t}\n\treturn String(value);\n}\nfunction toPrimitive<T>(this: Value<T>, hint?: 'string' | 'number' | 'default') {\n\tconst value = this();\n\tif (value === undefined) { return String(value); }\n\tif (value === null) { return String(value); }\n\tif (typeof (value as any)[Symbol.toPrimitive] === 'function') {\n\t\treturn (value as any)[Symbol.toPrimitive](hint);\n\t}\n\tif (hint === 'string') {\n\t\treturn String(value);\n\t}\n\tif (hint === 'number') {\n\t\treturn Number(value);\n\t}\n\treturn value;\n}\n\nfunction createValue<T, V extends Value<T> = Value<T>>(\n\trecover: () => T,\n\tsetValue?: (value: T, markChange: () => void) => void,\n\tstop: () => void = () => {},\n\tchange: () => void = () => {},\n): {value: V, trigger: Trigger} {\n\tfunction set(v: T, marked = false) {\n\t\tif (!setValue) { return; }\n\t\ttry {\n\t\t\tsetValue(v, () => { marked = true; });\n\t\t} finally {\n\t\t\tif (marked) {\n\t\t\t\ttrigger();\n\t\t\t}\n\t\t}\n\t}\n\tfunction get() {\n\t\tmarkRead(value, 'value');\n\t\treturn recover();\n\t}\n\tconst value: V = ((...v: [T] | [T, boolean] | []): T => {\n\t\tif (v.length) {\n\t\t\tset(v[0], v[1]);\n\t\t\treturn v[0];\n\t\t}\n\t\treturn get();\n\t}) as V;\n\tReflect.defineProperty(value, 'value', {\n\t\tget,\n\t\tset,\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t});\n\tReflect.defineProperty(value, 'valueOf', {\n\t\tvalue: valueOf,\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t});\n\tReflect.defineProperty(value, 'toString', {\n\t\tvalue: toString,\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t});\n\n\tReflect.defineProperty(value, Symbol.toPrimitive, {\n\t\tvalue: toPrimitive,\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t});\n\n\tfunction watch(cb: WatchCallback<T, V>): () => void {\n\t\tif (!callbacks) { return () => {}; }\n\t\tcb = safeify(cb);\n\t\tcallbacks.push(cb);\n\t\tchange();\n\t\tlet cancelled = false;\n\t\treturn () => {\n\t\t\tif (cancelled) { return; }\n\t\t\tcancelled = true;\n\t\t\tif (!callbacks) { return; }\n\t\t\tconst index = callbacks.findIndex(a => a === cb);\n\t\t\tif (index < 0) { return; }\n\t\t\tcallbacks.splice(index, 1);\n\t\t\tchange();\n\t\t};\n\t}\n\tlet callbacks: WatchCallback<T, V>[] | undefined = [];\n\tReflect.defineProperty(value, 'watch', {\n\t\tget() { return watch; },\n\t\tset() {},\n\t\tconfigurable: true,\n\t});\n\tconst trigger = (() => {\n\t\tif (!callbacks) { return; }\n\t\tmarkChange(value, 'value');\n\t\tfor (const cb of [...callbacks]) {\n\t\t\tcb(value, false);\n\t\t}\n\t}) as Trigger;\n\ttrigger.has = () => Boolean(callbacks?.length);\n\ttrigger.stop = () => {\n\t\tif (!callbacks) { return; }\n\t\tconst list = callbacks;\n\t\tcallbacks = undefined;\n\t\tfor (const cb of [...list]) {\n\t\t\tcb(value, true);\n\t\t}\n\t};\n\tvalues.add(value);\n\tlet stopped = false;\n\tvalue.stop = () => {\n\t\tif (stopped) { return; }\n\t\tstopped = true;\n\t\tstop();\n\t\ttrigger.stop();\n\n\t};\n\treturn {value, trigger};\n}\n/**\n * 创建引用值\n * @param value 初始值\n * @param options 选项\n */\nexport function value<T>(\n\tvalue: T,\n\toptions?: Options | boolean,\n): Value<T>;\nexport function value<T>(\n\tdef: T,\n\toptions?: Options | boolean,\n): Value<T> {\n\tconst proxy = options === true || options && options.proxy;\n\tlet source: T;\n\tlet proxyValue: T;\n\tconst { value } = createValue<T>(\n\t\t() => proxyValue,\n\t\t(v, mark) => {\n\t\t\tif (proxy) { v = recover(v); }\n\t\t\tif (v === source) { return; }\n\t\t\tsource = v;\n\t\t\tproxyValue = proxy ? encase(source) : source;\n\t\t\tmark();\n\t\t},\n\t);\n\tvalue(def);\n\treturn value;\n}\n\nexport interface ComputedOptions {\n\tpostpone?: boolean | 'priority';\n\tproxy?: boolean;\n}\n/**\n * 创建计算值\n * @param getter 取值方法\n * @param options 选项\n */\nexport function computed<T>(\n\tgetter: () => T,\n\toptions?: ComputedOptions | boolean,\n): Value<T>;\n/**\n * 创建可赋值计算值\n * @param getter 取值方法\n * @param setter 复制方法\n * @param options 选项\n */\nexport function computed<T>(\n\tgetter: () => T,\n\tsetter: (value: T) => void,\n\toptions?: ComputedOptions | boolean,\n): Value<T>;\nexport function computed<T>(\n\tgetter: () => T,\n\tsetter?: ((value: T) => void) | ComputedOptions | boolean,\n\toptions?: ComputedOptions | boolean,\n): Value<T>;\nexport function computed<T>(\n\tgetter: () => T,\n\tsetter?: ((value: T) => void) | ComputedOptions | boolean,\n\toptions?: ComputedOptions | boolean,\n): Value<T> {\n\tif (typeof setter !== 'function') {\n\t\toptions = setter;\n\t\tsetter = undefined;\n\t}\n\tconst setValue = setter;\n\tconst proxy = options === true || options && options.proxy;\n\tconst postpone = typeof options === 'object' && options?.postpone;\n\tlet source: T;\n\tlet proxyValue: T;\n\tlet stopped = false;\n\tlet computed = false;\n\tlet trigger: Trigger | undefined;\n\tconst executable = createExecutable(changed => {\n\t\tcomputed = !changed;\n\t\tif (changed  && trigger) {\n\t\t\ttrigger();\n\t\t}\n\t}, getter, { postpone });\n\tfunction run() {\n\t\tcomputed = true;\n\t\ttry {\n\t\t\tsource = executable();\n\t\t\tif (proxy) { source = recover(source); }\n\t\t\tproxyValue = proxy ? encase(source) : source;\n\t\t\treturn proxyValue;\n\t\t} catch(e) {\n\t\t\tif (!stopped) {\n\t\t\t\tcomputed = false;\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}\n\tlet value: Value<T>;\n\t({value, trigger} = createValue<T, Value<T>>(\n\t\t() => computed || stopped ? proxyValue : run(),\n\t\tsetValue && (v => setValue(proxy ? recover(v) : v)),\n\t\t() => {\n\t\t\tif (stopped) { return; }\n\t\t\tstopped = true;\n\t\t\tif (computed) { return; }\n\t\t\trun();\n\t\t},\n\t));\n\treturn value;\n\n}\n\nexport function merge<T, V extends Value<T> = Value<T>>(\n\tcb: WatchCallback<T, V>\n): WatchCallback<T, V> {\n\tlet oldValue: any;\n\tlet ran = false;\n\treturn (v, stopped) => {\n\t\tif (stopped) { return cb(v, stopped); }\n\t\tconst newValue = recover(v());\n\t\tif (newValue === oldValue && ran) { return; }\n\t\tran = true;\n\t\toldValue = newValue;\n\t\tcb(v, stopped);\n\t};\n}\n\ntype OffValue<V> = V extends Value<infer T> ? T : V;\n\nexport function mix<T extends object>(\n\tsource: T\n): { [K in keyof T]: OffValue<T[K]>; } {\n\tfor (const k of Reflect.ownKeys(source)) {\n\t\tconst descriptor = Reflect.getOwnPropertyDescriptor(source, k);\n\t\tif (!descriptor) { continue; }\n\t\tif (\n\t\t\t!('value' in descriptor)\n\t\t\t|| 'get' in descriptor\n\t\t\t|| 'set' in descriptor\n\t\t) { continue; }\n\t\tconst value = descriptor.value;\n\t\tif (!isValue(value)) { continue; }\n\t\tdescriptor.get = () => value.value;\n\t\tif (descriptor.writable) {\n\t\t\tdescriptor.set = v => (value as Value<any>).value = v;\n\t\t}\n\t\tdelete descriptor.value;\n\t\tdelete descriptor.writable;\n\t\tReflect.defineProperty(source, k, descriptor);\n\t}\n\treturn source as any;\n}\n"],"names":["printErrorLog","read","printError","info","print","undefined","console","error","encashable","v","Boolean","includes","safeify","fn","p","e","getIndexes","target","prop","String","getMapValue","map","key","def","has","get","value","set","markRead","indexes","propMap","Map","observe","options","oldRead","postpone","watchList","WeakMap","execWatch","watch","_watchList$get","forEach","w","waitList","getValue","f","priority","list","old","entries","_read","run","markChange","Set","add","wait","watchProp","cb","removed","delete","size","encase","nest","original","recover","nestLayer","Infinity","proxy","Proxy","receiver","Reflect","modified","setPrototypeOf","proto","oldProto","getPrototypeOf","defineProperty","attr","changed","desc","getOwnPropertyDescriptor","deleteProperty","deleted","ownKeys","__monitorable__recover__","equal","a","b","exec","cancelList","cancel","trigger","thisRead","result","obj","props","m","push","resultOnly","stop","createExecutable","values","WeakSet","isValue","x","valueOf","this","toString","toPrimitive","hint","Symbol","Number","createValue","setValue","change","marked","length","callbacks","cancelled","index","findIndex","splice","enumerable","configurable","_callbacks","stopped","source","proxyValue","mark","computed","getter","setter","_options","executable","merge","oldValue","ran","newValue","mix","k","descriptor","writable"],"mappings":"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"}