/*!
 * monitorable v0.1.0-alpha.2
 * (c) 2020 Fierflame
 * @license MIT
 */
let e,t,n;function r(t,n=!1){n||"function"!=typeof t&&void 0!==t?"function"!=typeof e?console.error(t):e(t):e=t}function o(e){return(...t)=>{try{e(...t)}catch(e){r(e,!0)}}}function f(e,t,n){if(e.has(t))return e.get(t);const r=n();return e.set(t,r),r}function c(e){return Boolean(e&&["object","function"].includes(typeof e))}function i(e,n=0){if(!c(e))return e;const r=u(e),o=!0===n?1/0:n||0,f=new Proxy(r,{set(e,t,r,o){if(!1===n)return Reflect.set(e,t,r,o);const f=Reflect.has(e,t),c=Reflect.set(e,t,r,i(o));return c?(f!==Reflect.has(e,t)&&y(e,!0),c):c},get(e,c,u){if(t===f&&"__monitorable__recover__"===c)return void(t=r);if(!1===n)return Reflect.get(e,c,u);s(e,c);const l=Reflect.get(e,c,i(u));return o>0?i(l,o-1):l},setPrototypeOf(e,t){if(!1===n)return Reflect.setPrototypeOf(e,t);const r=Reflect.getPrototypeOf(e),o=Reflect.setPrototypeOf(e,t);return o&&r!==t&&y(e,!1),o},getPrototypeOf(e){if(!1===n)return Reflect.getPrototypeOf(e);s(e,!1);const t=Reflect.getPrototypeOf(e);return o>0?i(t,o-1):t},defineProperty(e,t,r){if(!1===n)return Reflect.defineProperty(e,t,r);let o=!0;if("value"in r){const n=Reflect.getOwnPropertyDescriptor(e,t);n&&"value"in n&&u(r.value)===u(n.value)&&(o=!1)}const f=Reflect.defineProperty(e,t,r);return o&&f&&y(e,t),f},getOwnPropertyDescriptor:(e,t)=>!1===n?Reflect.getOwnPropertyDescriptor(e,t):(s(e,t),Reflect.getOwnPropertyDescriptor(e,t)),deleteProperty(e,t){if(!1===n)return Reflect.deleteProperty(e,t);const r=Reflect.has(e,t),o=Reflect.deleteProperty(e,t);return r&&!Reflect.has(e,t)&&(y(e,t),y(e,!0)),o},ownKeys:e=>!1===n?Reflect.ownKeys(e):(s(e,!0),Reflect.ownKeys(e)),has:(e,t)=>!1===n?Reflect.has(e,t):(s(e,!0),Reflect.has(e,t))});return f}function u(e){if(!e)return e;if(!c(e))return e;let n=e;try{t=e,n=e.__monitorable__recover__}catch(e){}return n=t,t=!1,n?"object"==typeof n?n:"function"==typeof n?n:e:e}function l(e,t){return u(e)===u(t)}function s(e,t){if(!n)return;const r=f(n,e,()=>new Set);"number"==typeof t&&(t=String(t)),r.add(t)}function a(e,t=new Map,r=!1){const o=n;n=t;try{return e()}catch(e){throw r&&t.clear(),e}finally{n=o}}const p=new WeakMap;function y(e,t){var n,r;if(!e)return;if(!c(e))return;if("number"==typeof t)t=String(t);else if("symbol"!=typeof t&&"string"!=typeof t&&"boolean"!=typeof t)return;const o=null===(n=p.get(e))||void 0===n?void 0:null===(r=n.get)||void 0===r?void 0:r.call(n,t);if(o)for(const e of[...o])e()}function d(e,t,n){if(!e)return()=>{};if("object"!=typeof e&&"function"!=typeof e)return()=>{};if("function"!=typeof n)return()=>{};if("number"==typeof t&&(t=String(t)),"symbol"!=typeof t&&"string"!=typeof t&&"boolean"!=typeof t)return()=>{};const r=t;e=u(e);let c=p.get(e);c||(c=new Map,p.set(e,c));const i=f(c,r,()=>new Set);n=o(n),i.add(n);let l=!1;return()=>{l||(l=!0,i.delete(n),i.size||c&&(c.delete(r),c.size||p.delete(e)))}}function g(e,t){let n;function r(){if(!n)return!1;const e=n;return n=void 0,e.forEach(e=>e()),!0}function f(){r()&&t(!0)}function c(){r();const o=new Map;try{return a(e,o,!0)}finally{if(o.size){n=[];for(let[e,t]of o)for(const r of t)n.push(d(e,r,f))}else t(!1)}}return t=o(t),c.stop=()=>{r()&&t(!1)},c}const v=new WeakSet;function R(e){return v.has(e)}function h(e,t,n=(()=>{}),r=(()=>{})){function f(e,n=!1){if(t)try{t(e,()=>{n=!0})}finally{n&&a()}}function c(){return s(i,"value"),e()}const i=(...e)=>e.length?(f(e[0],e[1]),e[0]):c();function u(e){if(!l)return()=>{};e=o(e),l.push(e),r();let t=!1;return()=>{if(t)return;if(t=!0,!l)return;const n=l.findIndex(t=>t===e);n<0||(l.splice(n,1),r())}}Reflect.defineProperty(i,"value",{get:c,set:f,enumerable:!0,configurable:!0});let l=[];Reflect.defineProperty(i,"watch",{get:()=>u,set(){},configurable:!0});const a=()=>{if(l){y(i,"value");for(const e of[...l])e(i,!1)}};a.has=()=>{var e;return Boolean(null===(e=l)||void 0===e?void 0:e.length)},a.stop=()=>{if(!l)return;const e=l;l=void 0;for(const t of[...e])t(i,!0)},v.add(i);let p=!1;return i.stop=()=>{p||(p=!0,n(),a.stop())},{value:i,trigger:a}}function w(e,t){const n=!0===t||t&&t.proxy;let r,o;const{value:f}=h(()=>o,(e,t)=>{n&&(e=u(e)),e!==r&&(r=e,o=n?i(r):r,t())});return f(e),f}function P(e,t,n){"function"!=typeof t&&(n=t,t=void 0);const r=t,o=!0===n||n&&n.proxy;let f,c,l,s=!1,a=!1;const p=g(e,e=>{a=!e,e&&l&&l()});function y(){a=!0;try{return f=p(),o&&(f=u(f)),c=o?i(f):f,c}catch(e){throw s||(a=!1),e}}let d;return({value:d,trigger:l}=h(()=>a||s?c:y(),r&&(e=>r(o?u(e):e)),()=>{s||(s=!0,a||y())})),d}function b(e){let t,n=!1;return(r,o)=>{if(o)return e(r,o);const f=u(r());f===t&&n||(n=!0,t=f,e(r,o))}}function O(e){for(const t of Reflect.ownKeys(e)){const n=Reflect.getOwnPropertyDescriptor(e,t);if(!n)continue;if(!("value"in n)||"get"in n||"set"in n)continue;const r=n.value;R(r)&&(n.get=()=>r.value,n.writable&&(n.set=e=>r.value=e),delete n.value,delete n.writable,Reflect.defineProperty(e,t,n))}return e}export{P as computed,g as createExecutable,i as encase,l as equal,f as getMapValue,R as isValue,y as markChange,s as markRead,b as merge,O as mix,a as observe,r as printError,u as recover,o as safeify,w as value,d as watchProp};
//# sourceMappingURL=monitorable.esm.min.js.map
