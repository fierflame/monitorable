/*!
 * monitorable v0.0.0
 * (c) 2020 Fierflame
 * @license MIT
 */
function t(t){return(...e)=>{try{t(...e)}catch(t){console.error(t)}}}const e=new WeakMap,n={get:(t,e,n)=>(i(t,"number"==typeof e?String(e):e),Reflect.get(t,e,n)),set:(t,e,n,r)=>(Reflect.get(t,e,r)!==n&&l(t,"number"==typeof e?String(e):e),Reflect.set(t,e,n,r))};function r(t){return function(t){return Boolean(t&&["object","function"].includes(typeof t))}(t)?e.has(t)?t:new Proxy(t,n):t}function o(t){return e.get(t)||t}let f;function i(t,e){if(!f)return;let n=f.get(t);n||(n=new Set,f.set(t,n)),n.add(e)}const u=new WeakMap;function c(t,e,n){if(!t)return()=>{};if("object"!=typeof t&&"function"!=typeof t)return()=>{};if("function"!=typeof n)return()=>{};if("symbol"!=typeof e&&"string"!=typeof e)return()=>{};t=o(t);let r=u.get(t);r||(r=new Map,u.set(t,r));let f=r.get(e);f||(f=[],r.set(e,f)),f.push(n);let i=!1;return()=>{if(i)return;if(i=!0,!f)return;const o=f.findIndex(t=>t===n);o<0||(f.splice(o,1),f.length||r&&(r.delete(e),r.size||u.delete(t)))}}function l(t,e){var n,r;if(!t)return;if("object"!=typeof t&&"function"!=typeof t)return;if("number"==typeof e)e=String(e);else if("symbol"!=typeof e&&"string"!=typeof e)return;const o=null===(n=u.get(t))||void 0===n?void 0:null===(r=n.get)||void 0===r?void 0:r.call(n,e);if(o)for(const t of[...o])try{t()}catch(t){console.error(t)}}const s=new WeakSet;function a(t){return s.has(t)}function p(e,n,r=(()=>{}),o=(()=>{})){function f(t,n=!1){try{return e(t,()=>{n=!0})}finally{n&&y()}}function u(){return i(c,"value"),n()}const c=(...t)=>t.length?(f(t[0],t[1]),t[0]):u();function a(e){if(!p)return()=>{};e=t(e),p.push(e),o();let n=!1;return()=>{if(n)return;if(n=!0,!p)return;const t=p.findIndex(t=>t===e);t<0||(p.splice(t,1),o())}}Reflect.defineProperty(c,"value",{get:u,set:f,enumerable:!0,configurable:!0});let p=[];Reflect.defineProperty(c,"watch",{get:()=>a,set(){},configurable:!0});const y=()=>{if(p){l(c,"value");for(const t of[...p])t(c,!1)}};y.has=()=>{var t;return Boolean(null===(t=p)||void 0===t?void 0:t.length)},y.stop=()=>{if(!p)return;const t=p;p=void 0;for(const e of[...t])e(c,!0)},s.add(c);let g=!1;return c.stop=()=>{g||(g=!0,r(),y.stop())},{value:c,trigger:y}}function y(t,e){const n=!0===e||e&&e.proxy;let f,i;const{value:u}=p((t,e)=>{n&&(t=o(t)),t!==f&&(f=t,i=n?r(f):f,e())},()=>i);return u(t),u}function g(e,n){const i=!0===n||n&&n.proxy;let u,l,s,a=!1,y=!1;const g=function(e,n){let r;function o(){if(!r)return!1;const t=r;return r=void 0,t.forEach(t=>t()),!0}function i(){o()&&n(!0)}function u(){o();const t=new Map,u=f;f=t;try{return e()}catch(e){throw t.clear(),e}finally{if(f=u,t.size){r=[];for(let[e,n]of t)for(const t of n)r.push(c(e,t,i))}else n(!1)}}return n=t(n),u.stop=()=>{o()&&n(!1)},u}(e,t=>{y=!t,t&&s&&s()});function d(){y=!0;try{return u=g(),i&&(u=o(u)),l=i?r(u):u,l}catch(t){throw a||(y=!1),t}}let v;return({value:v,trigger:s}=p((t,e)=>{},()=>y||a?l:d(),()=>{a||(a=!0,y||d())})),v}function d(t){let e,n=!1;return(r,f)=>{if(f)return t(r,f);const i=o(r());i===e&&n||(n=!0,e=i,t(r,f))}}function v(t){for(const e of Reflect.ownKeys(t)){const n=Reflect.getOwnPropertyDescriptor(t,e);if(!n)continue;if("get"in n||"set"in n||!("value"in n))continue;const r=n.value;a(r)&&(n.get=()=>r(),n.writable&&(n.set=t=>r(t)),delete n.value,delete n.writable,Reflect.defineProperty(t,e,n))}return t}export{g as computed,a as isValue,d as merge,v as mix,y as value};
//# sourceMappingURL=monitorable.esm.min.js.map
