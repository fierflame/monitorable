{"version":3,"file":"monitorable.common.min.js","sources":["../src/utils.ts","../src/state.ts","../src/executable.ts","../src/value.ts"],"sourcesContent":["\nlet printErrorLog: undefined | ((info: any) => void);\n/** 设置或移除错误打印函数 */\nexport function printError(fn?: (info: any) => void): void;\n/** 打印错误 */\nexport function printError(info: any, print: true): void;\n/** 打印错误 */\nexport function printError(info: any): void;\nexport function printError(info?: string | Error | ((info: any) => void), print = false) {\n\tif (!print && (typeof info === 'function' || info === undefined)) {\n\t\tprintErrorLog = info;\n\t\treturn;\n\t}\n\tif (typeof printErrorLog === 'function') {\n\t\tprintErrorLog(info);\n\t\treturn;\n\t}\n\tconsole.error(info);\n}\n\n/** 回调函数安全化处理 */\nexport function safeify<T extends any[]>(fn: (...p: T) => void): (...p: T) => void {\n\treturn (...p) => {\n\t\ttry {\n\t\t\tfn(...p);\n\t\t} catch(e) {\n\t\t\tprintError(e, true);\n\t\t}\n\t};\n}\n\nexport function getMepValue<K, V>(map: Map<K, V>, key: K, def: () => V): V {\n\tif (map.has(key)) {\n\t\treturn map.get(key)!;\n\t}\n\tconst value = def();\n\tmap.set(key, value);\n\treturn value;\n}\n","import { safeify, getMepValue } from './utils';\n\nconst ValueMap = new WeakMap<object | Function, object | Function>();\n\n/**\n * 判断对象是否可被代理\n */\nfunction isProxyable(v: any): v is object | Function {\n\treturn Boolean(v && ['object', 'function'].includes(typeof v));\n}\n\n/**\n * 获取被代理对象\n * @param value 要被代理的对象\n * @param nest 递归代理的层数\n */\nexport function getProxy<T>(value: T, nest: number | boolean = 0): T {\n\tif (!isProxyable(value)) { return value; }\n\tif (ValueMap.has(value)) { return value; }\n\tconst nestLayer: number = nest === true ? Infinity : nest || 0;\n\tconst proxy = new Proxy(value, {\n\t\tset(target, prop, value, receiver) {\n\t\t\tif (nest === false) { return Reflect.set(target, prop, value, receiver); }\n\t\t\tconst has = Reflect.has(target, prop);\n\t\t\tconst modified = Reflect.set(target, prop, value, getProxy(receiver));\n\t\t\tif (!modified) { return modified; }\n\t\t\tif (has !== Reflect.has(target, prop)) {\n\t\t\t\tmarkChange(target, true);\n\t\t\t}\n\t\t\treturn modified;\n\t\t},\n\t\tget(target, prop, receiver) {\n\t\t\tif (nest === false) { return Reflect.get(target, prop, receiver); }\n\t\t\tmarkRead(target, prop);\n\t\t\tconst value = Reflect.get(target, prop, getProxy(receiver));\n\t\t\tif (nestLayer > 0) {\n\t\t\t\treturn getProxy(value, nestLayer - 1);\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\t\tsetPrototypeOf(target, proto) {\n\t\t\tif (nest === false) { return Reflect.setPrototypeOf(target, proto); }\n\t\t\tconst oldProto = Reflect.getPrototypeOf(target);\n\t\t\tconst modified = Reflect.setPrototypeOf(target, proto);\n\t\t\tif (modified && oldProto !== proto) {\n\t\t\t\tmarkChange(target, false);\n\t\t\t}\n\t\t\treturn modified;\n\t\t},\n\t\tgetPrototypeOf(target) {\n\t\t\tif (nest === false) { return Reflect.getPrototypeOf(target); }\n\t\t\tmarkRead(target, false);\n\t\t\tconst value: any = Reflect.getPrototypeOf(target);\n\t\t\tif (nestLayer > 0) {\n\t\t\t\treturn getProxy(value, nestLayer - 1);\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\t\tdefineProperty(target, prop, attributes) {\n\t\t\tif (nest === false) { return Reflect.defineProperty(target, prop, attributes); }\n\t\t\tlet changed = true;\n\t\t\tif ('value' in attributes) {\n\t\t\t\tconst descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\t\t\t\tif (descriptor && 'value' in descriptor && getValue(attributes.value) === getValue(descriptor.value)) {\n\t\t\t\t\tchanged = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst modified = Reflect.defineProperty(target, prop, attributes);\n\t\t\tif (changed && modified) {\n\t\t\t\tmarkChange(target, prop);\n\t\t\t}\n\t\t\treturn modified;\n\t\t},\n\t\tgetOwnPropertyDescriptor(target, prop) {\n\t\t\tif (nest === false) { return Reflect.getOwnPropertyDescriptor(target, prop); }\n\t\t\tmarkRead(target, prop);\n\t\t\treturn Reflect.getOwnPropertyDescriptor(target, prop);\n\t\t},\n\t\tdeleteProperty(target, prop) {\n\t\t\tif (nest === false) { return Reflect.deleteProperty(target, prop); }\n\t\t\tconst has = Reflect.has(target, prop);\n\t\t\tconst deleted = Reflect.deleteProperty(target, prop);\n\t\t\tif (has && !Reflect.has(target, prop)) {\n\t\t\t\tmarkChange(target, prop);\n\t\t\t\tmarkChange(target, true);\n\t\t\t}\n\t\t\treturn deleted;\n\t\t},\n\t\townKeys(target) {\n\t\t\tif (nest === false) { return Reflect.ownKeys(target); }\n\t\t\tmarkRead(target, true);\n\t\t\treturn Reflect.ownKeys(target);\n\t\t},\n\t\thas(target, prop) {\n\t\t\tif (nest === false) { return Reflect.has(target, prop); }\n\t\t\tmarkRead(target, true);\n\t\t\treturn Reflect.has(target, prop);\n\t\t},\n\t});\n\treturn proxy;\n}\n/** 获取被代理的原始值 */\nexport function getValue<T>(v: T): T {\n\treturn ValueMap.get(v as any) as T | undefined || v;\n}\nexport function equal(a: any, b: any): boolean {\n\treturn getValue(a) === getValue(b);\n}\n\nexport type ReadMap =  Map<object | Function, Set<string | boolean | symbol>>;\n\n/** 已被读取的 */\nlet read: ReadMap | undefined;\n\n/**\n * 标记已读状态\n * @param obj  要标记的对象\n * @param prop 要标记的属性\n */\nexport function markRead(obj: object | Function, prop: string | number | boolean | symbol) {\n\tif (!read) { return; }\n\tconst set = getMepValue(read, obj, () => new Set());\n\tif (typeof prop === 'number') {\n\t\tprop = String(prop);\n\t}\n\tset.add(prop);\n}\n/**\n * 监听函数的执行，并将执行过程中读取的对象值设置到 map 中\n * @param fn 要执行的含糊\n * @param map 用于存储被读取对象的 map\n * @param clear 是否在发送错误时清空 map\n */\nexport function observe<T>(fn: () => T, map: ReadMap = new Map(), clear = false): T {\n\tconst oldRead = read;\n\tread = map;\n\ttry {\n\t\treturn fn();\n\t} catch(e) {\n\t\tif (clear) {\n\t\t\tmap.clear();\n\t\t}\n\t\tthrow e;\n\t} finally {\n\t\tread = oldRead;\n\t}\n}\n\n\nconst watchList = new WeakMap<object | Function, Map<string | boolean | symbol, Set<() => void>>>();\n/**\n * 标记属性的修改，同时触发监听函数\n * @param target 要标记的对象\n * @param prop   要标记的属性 特别的，false 表示原型，true 表示成员\n */\nexport function markChange(target: object | Function, prop: string | number | boolean | symbol) {\n\tif (!target) { return; }\n\tif (!(typeof target === 'object' || typeof target === 'function')) { return; }\n\tif (typeof prop === 'number') {\n\t\tprop = String(prop);\n\t} else if (typeof prop !== 'symbol' && typeof prop !== 'string' && typeof prop !== 'boolean') {\n\t\treturn;\n\t}\n\n\tconst watch = watchList.get(target)?.get?.(prop);\n\tif (!watch) { return; }\n\tfor (const w of [...watch]) {\n\t\tw();\n\t}\n}\n\n/**\n * 监听对象属性的变化\n * @param target 要监听的对象\n * @param prop   要监听的属性名 特别的，false 表示原型，true 表示成员\n * @param fn     属性改变后触发的函数\n */\nexport function watchProp(target: object | Function, prop: string | number | boolean | symbol, cb: () => void): () => void {\n\tif (!target) { return () => {}; }\n\tif (!(typeof target === 'object' || typeof target === 'function')) { return () => {}; }\n\tif (typeof cb !== 'function') { return  () => {}; }\n\tif (typeof prop === 'number') { prop = String(prop); }\n\tif (typeof prop !== 'symbol' && typeof prop !== 'string' && typeof prop !== 'boolean') { return () => {}; }\n\tconst key = prop;\n\ttarget = getValue(target);\n\tlet map = watchList.get(target);\n\tif (!map) {\n\t\tmap = new Map();\n\t\twatchList.set(target, map);\n\t}\n\tconst list = getMepValue(map, key, () => new Set());\n\tcb = safeify(cb);\n\tlist.add(cb);\n\tlet removed = false;\n\treturn () => {\n\t\tif (removed) { return; }\n\t\tremoved = true;\n\n\t\t// 从当前列表中移除\n\t\tlist.delete(cb);\n\n\t\t// 从属性关联中删除\n\t\tif (list.size) { return; }\n\t\tif (!map) { return; }\n\t\tmap.delete(key);\n\n\t\t// 映射列表中删除\n\t\tif (map.size) { return; }\n\t\twatchList.delete(target);\n\t};\n\n}\n","import { observe, watchProp, ReadMap } from './state';\nimport { safeify } from './utils';\n\nexport interface Executable<T> {\n\t(): T;\n\tstop(): void;\n}\n/**\n * 创建可监听执行函数\n * @param fn 要监听执行的函数\n * @param cb 当监听的值发生可能改变时触发的回调函数，单如果没有被执行的函数或抛出错误，将会在每次 fn 被执行后直接执行\n */\nexport function createExecutable<T>(fn: () => T, cb: (changed: boolean) => void): Executable<T> {\n\tcb = safeify(cb);\n\tlet cancelList: (() => void)[] | undefined;\n\t/** 取消监听 */\n\tfunction cancel() {\n\t\tif (!cancelList) { return false; }\n\t\tconst list = cancelList;\n\t\tcancelList = undefined;\n\t\tlist.forEach(f => f());\n\t\treturn true;\n\t}\n\tfunction trigger() {\n\t\tif (!cancel()) { return; }\n\t\tcb(true);\n\t};\n\tfunction exec() {\n\t\tcancel();\n\t\tconst thisRead: ReadMap = new Map();\n\t\ttry {\n\t\t\treturn observe(fn, thisRead, true);\n\t\t} finally {\n\t\t\tif (thisRead.size) {\n\t\t\t\tcancelList = [];\n\t\t\t\tfor ( let [obj, props] of thisRead) {\n\t\t\t\t\tfor (const p of props) {\n\t\t\t\t\t\tcancelList.push(watchProp(obj, p, trigger));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcb(false);\n\t\t\t}\n\t\t}\n\t}\n\texec.stop = () => {\n\t\tif (!cancel()) { return; }\n\t\tcb(false);\n\t};\n\treturn exec;\n}\n","import { markRead, markChange, getValue, getProxy } from './state';\nimport { safeify } from './utils';\nimport { createExecutable } from './executable';\n\n/** 取消监听的方法 */\nexport interface CancelWatch {\n\t(): void;\n}\n/** 可监听值 */\nexport interface Value<T> {\n\t(): T;\n\t(v: T, mrak?: boolean): T;\n\tvalue: T;\n\twatch(cb: WatchCallback<T, this>): CancelWatch;\n\tstop(): void;\n}\n/** 监听函数 */\nexport interface WatchCallback<T, V extends Value<T> = Value<T>> {\n\t(v: V, stoped: boolean): void;\n}\nconst values = new WeakSet<Value<any>>();\nexport function isValue(x: any): x is Value<any> {\n\treturn values.has(x);\n}\n/** 触发监听 */\ninterface Trigger {\n\t(): void;\n\t/** 是否存在监听函数 */\n\thas(): boolean;\n\t/** 停止监听 */\n\tstop(): void;\n}\nexport interface Options {\n\tproxy?: boolean;\n}\n\n\nfunction createValue<T, V extends Value<T> = Value<T>>(\n\tgetValue: () => T,\n\tsetValue?: (value: T, markChange: () => void) => void,\n\tstop: () => void = () => {},\n\tchange: () => void = () => {},\n): {value: V, trigger: Trigger} {\n\tfunction set(v: T, marked = false) {\n\t\tif (!setValue) { return; }\n\t\ttry {\n\t\t\tsetValue(v, () => { marked = true; });\n\t\t} finally {\n\t\t\tif (marked) {\n\t\t\t\ttrigger();\n\t\t\t}\n\t\t}\n\t}\n\tfunction get() {\n\t\tmarkRead(value, 'value');\n\t\treturn getValue();\n\t}\n\tconst value: V = ((...v: [T] | [T, boolean] | []): T => {\n\t\tif (v.length) {\n\t\t\tset(v[0], v[1]);\n\t\t\treturn v[0];\n\t\t}\n\t\treturn get();\n\t}) as V;\n\tReflect.defineProperty(value, 'value', {\n\t\tget,\n\t\tset,\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t});\n\n\tfunction watch(cb: WatchCallback<T, V>): () => void {\n\t\tif (!callbacks) { return () => {}; }\n\t\tcb = safeify(cb);\n\t\tcallbacks.push(cb);\n\t\tchange();\n\t\tlet cancelled = false;\n\t\treturn () => {\n\t\t\tif (cancelled) { return; }\n\t\t\tcancelled = true;\n\t\t\tif (!callbacks) { return; }\n\t\t\tconst index = callbacks.findIndex(a => a === cb);\n\t\t\tif (index < 0) { return; }\n\t\t\tcallbacks.splice(index, 1);\n\t\t\tchange();\n\t\t};\n\t}\n\tlet callbacks: WatchCallback<T, V>[] | undefined = [];\n\tReflect.defineProperty(value, 'watch', {\n\t\tget() { return watch; },\n\t\tset() {},\n\t\tconfigurable: true,\n\t});\n\tconst trigger = (() => {\n\t\tif (!callbacks) { return; }\n\t\tmarkChange(value, 'value');\n\t\tfor (const cb of [...callbacks]) {\n\t\t\tcb(value, false);\n\t\t}\n\t}) as Trigger;\n\ttrigger.has = () => Boolean(callbacks?.length);\n\ttrigger.stop = () => {\n\t\tif (!callbacks) { return; }\n\t\tconst list = callbacks;\n\t\tcallbacks = undefined;\n\t\tfor (const cb of [...list]) {\n\t\t\tcb(value, true);\n\t\t}\n\t};\n\tvalues.add(value);\n\tlet stoped = false;\n\tvalue.stop = () => {\n\t\tif (stoped) { return; }\n\t\tstoped = true;\n\t\tstop();\n\t\ttrigger.stop();\n\n\t};\n\treturn {value, trigger};\n}\n/**\n * 创建引用值\n * @param value 初始值\n * @param options 选项\n */\nexport function value<T>(value: T, options?: Options | boolean): Value<T>;\nexport function value<T>(def: T, options?: Options | boolean): Value<T> {\n\tconst proxy = options === true || options && options.proxy;\n\tlet source: T;\n\tlet proxyed: T;\n\tconst { value } = createValue<T>(\n\t\t() => proxyed,\n\t\t(v, mark) => {\n\t\t\tif (proxy) { v = getValue(v); }\n\t\t\tif (v === source) { return; }\n\t\t\tsource = v;\n\t\t\tproxyed = proxy ? getProxy(source) : source;\n\t\t\tmark();\n\t\t},\n\t);\n\tvalue(def);\n\treturn value;\n}\n\n/**\n * 创建计算值\n * @param getter 取值方法\n * @param options 选项\n */\nexport function computed<T>(getter: () => T, options?: Options | boolean): Value<T>;\n/**\n * 创建可赋值计算值\n * @param getter 取值方法\n * @param setter 复制方法\n * @param options 选项\n */\nexport function computed<T>(getter: () => T, setter: (value: T) => void, options?: Options | boolean): Value<T>;\nexport function computed<T>(getter: () => T, setter?: ((value: T) => void) | Options | boolean, options?: Options | boolean): Value<T>;\nexport function computed<T>(getter: () => T, setter?: ((value: T) => void) | Options | boolean, options?: Options | boolean): Value<T> {\n\tif (typeof setter !== 'function') {\n\t\toptions = setter;\n\t\tsetter = undefined;\n\t}\n\tconst setValue = setter;\n\tconst proxy = options === true || options && options.proxy;\n\tlet source: T;\n\tlet proxyed: T;\n\tlet stoped = false;\n\tlet computed = false;\n\tlet trigger: Trigger | undefined;\n\tconst executable = createExecutable(getter, changed => {\n\t\tcomputed = !changed;\n\t\tif (changed  && trigger) {\n\t\t\ttrigger();\n\t\t}\n\t});\n\tfunction run() {\n\t\tcomputed = true;\n\t\ttry {\n\t\t\tsource = executable();\n\t\t\tif (proxy) { source = getValue(source); }\n\t\t\tproxyed = proxy ? getProxy(source) : source;\n\t\t\treturn proxyed;\n\t\t} catch(e) {\n\t\t\tif (!stoped) {\n\t\t\t\tcomputed = false;\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}\n\tlet value: Value<T>;\n\t({value, trigger} = createValue<T, Value<T>>(\n\t\t() => computed || stoped ? proxyed : run(),\n\t\tsetValue && (v => setValue(proxy ? getValue(v) : v)),\n\t\t() => {\n\t\t\tif (stoped) { return; }\n\t\t\tstoped = true;\n\t\t\tif (computed) { return; }\n\t\t\trun();\n\t\t},\n\t));\n\treturn value;\n\n}\n\nexport function merge<T, V extends Value<T> = Value<T>>(cb: WatchCallback<T, V>): WatchCallback<T, V> {\n\tlet oldValue: any;\n\tlet runed = false;\n\treturn (v, stoped) => {\n\t\tif (stoped) { return cb(v, stoped); }\n\t\tconst newValue = getValue(v());\n\t\tif (newValue === oldValue && runed) { return; }\n\t\truned = true;\n\t\toldValue = newValue;\n\t\tcb(v, stoped);\n\t};\n}\n\ntype OffValue<V> = V extends Value<infer T> ? T : V;\n\nexport function mix<T extends object>(source: T): { [K in keyof T]: OffValue<T[K]>; } {\n\tfor (const k of Reflect.ownKeys(source)) {\n\t\tconst descriptor = Reflect.getOwnPropertyDescriptor(source, k);\n\t\tif (!descriptor) { continue; }\n\t\tif ('get' in descriptor || 'set' in descriptor || !('value' in descriptor)) { continue; }\n\t\tconst value = descriptor.value;\n\t\tif (!isValue(value)) { continue; }\n\t\tdescriptor.get = () => value.value;\n\t\tif (descriptor.writable) {\n\t\t\tdescriptor.set = v => (value as Value<any>).value = v;\n\t\t}\n\t\tdelete descriptor.value;\n\t\tdelete descriptor.writable;\n\t\tReflect.defineProperty(source, k, descriptor);\n\t}\n\treturn source as any;\n}\n"],"names":["printErrorLog","printError","info","print","undefined","console","error","safeify","fn","p","e","getMepValue","map","key","def","has","get","value","set","ValueMap","WeakMap","getProxy","nest","v","Boolean","includes","nestLayer","Infinity","Proxy","target","prop","receiver","Reflect","modified","markChange","markRead","setPrototypeOf","proto","oldProto","getPrototypeOf","defineProperty","attributes","changed","descriptor","getOwnPropertyDescriptor","getValue","deleteProperty","deleted","ownKeys","read","obj","Set","String","add","observe","Map","clear","oldRead","watchList","watch","_watchList$get","_watchList$get$get","w","watchProp","cb","list","removed","delete","size","createExecutable","cancelList","cancel","forEach","f","trigger","exec","thisRead","props","push","stop","values","WeakSet","isValue","x","createValue","setValue","change","marked","length","callbacks","cancelled","index","findIndex","a","splice","enumerable","configurable","_callbacks","stoped","getter","setter","options","proxy","source","proxyed","computed","executable","run","b","oldValue","runed","newValue","k","writable","mark"],"mappings":"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"}