{"version":3,"file":"monitorable.common.min.js","sources":["../src/utils.ts","../src/state.ts","../src/executable.ts","../src/value.ts"],"sourcesContent":["\nlet printErrorLog: undefined | ((info: any) => void);\n/** 设置或移除错误打印函数 */\nexport function printError(fn?: (info: any) => void): void;\n/** 打印错误 */\nexport function printError(info: any, print: true): void;\n/** 打印错误 */\nexport function printError(info: any): void;\nexport function printError(\n\tinfo?: string | Error | ((info: any) => void),\n\tprint = false\n) {\n\tif (!print && (typeof info === 'function' || info === undefined)) {\n\t\tprintErrorLog = info;\n\t\treturn;\n\t}\n\tif (typeof printErrorLog === 'function') {\n\t\tprintErrorLog(info);\n\t\treturn;\n\t}\n\tconsole.error(info);\n}\n\n/** 回调函数安全化处理 */\nexport function safeify<T extends any[]>(\n\tfn: (...p: T) => void\n): (...p: T) => void {\n\treturn (...p) => {\n\t\ttry {\n\t\t\tfn(...p);\n\t\t} catch(e) {\n\t\t\tprintError(e, true);\n\t\t}\n\t};\n}\n\nexport function getMapValue<K, V>(\n\tmap: Map<K, V>,\n\tkey: K,\n\tdef: () => V,\n): V;\nexport function getMapValue<K extends object, V>(\n\tmap: WeakMap<K, V>,\n\tkey: K,\n\tdef: () => V,\n): V;\nexport function getMapValue<K, V>(\n\tmap: WeakMap<K & object, V> | Map<K, V>,\n\tkey: K,\n\tdef: () => V,\n): V {\n\tif (map.has(key as any)) {\n\t\treturn map.get(key as any)!;\n\t}\n\tconst value = def();\n\tmap.set(key as any, value);\n\treturn value;\n}\n","import { safeify, getMapValue } from './utils';\n\n/**\n * 判断对象是否可被代理\n */\nfunction isProxyable(v: any): v is object | Function {\n\treturn Boolean(v && ['object', 'function'].includes(typeof v));\n}\n\nlet getValue: any;\n/**\n * 获取被代理对象\n * @param obj  要被代理的对象\n * @param nest 递归代理的层数\n */\nexport function encase<T>(value: T, nest: number | boolean = 0): T {\n\tif (!isProxyable(value)) { return value; }\n\tconst original = recover(value);\n\tconst nestLayer: number = nest === true ? Infinity : nest || 0;\n\tconst proxy = new Proxy(original, {\n\t\tset(target, prop, value, receiver) {\n\t\t\tif (nest === false) {\n\t\t\t\treturn Reflect.set(target, prop, value, receiver);\n\t\t\t}\n\t\t\tconst has = Reflect.has(target, prop);\n\t\t\tconst modified =\n\t\t\t\tReflect.set(target, prop, value, encase(receiver));\n\t\t\tif (!modified) { return modified; }\n\t\t\tif (has !== Reflect.has(target, prop)) {\n\t\t\t\tmarkChange(target, true);\n\t\t\t}\n\t\t\treturn modified;\n\t\t},\n\t\tget(target, prop, receiver) {\n\t\t\tif (getValue === proxy) {\n\t\t\t\tif (prop === '__monitorable__recover__') {\n\t\t\t\t\tgetValue = original;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nest === false) {\n\t\t\t\treturn Reflect.get(target, prop, receiver);\n\t\t\t}\n\t\t\tmarkRead(target, prop);\n\t\t\tconst value = Reflect.get(target, prop, encase(receiver));\n\t\t\tif (nestLayer > 0) { return encase(value, nestLayer - 1); }\n\t\t\treturn value;\n\t\t},\n\t\tsetPrototypeOf(target, proto) {\n\t\t\tif (nest === false) {\n\t\t\t\treturn Reflect.setPrototypeOf(target, proto);\n\t\t\t}\n\t\t\tconst oldProto = Reflect.getPrototypeOf(target);\n\t\t\tconst modified = Reflect.setPrototypeOf(target, proto);\n\t\t\tif (modified && oldProto !== proto) {\n\t\t\t\tmarkChange(target, false);\n\t\t\t}\n\t\t\treturn modified;\n\t\t},\n\t\tgetPrototypeOf(target) {\n\t\t\tif (nest === false) {\n\t\t\t\treturn Reflect.getPrototypeOf(target);\n\t\t\t}\n\t\t\tmarkRead(target, false);\n\t\t\tconst value: any = Reflect.getPrototypeOf(target);\n\t\t\tif (nestLayer > 0) {\n\t\t\t\treturn encase(value, nestLayer - 1);\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\t\tdefineProperty(target, prop, attr) {\n\t\t\tif (nest === false) {\n\t\t\t\treturn Reflect.defineProperty(target, prop, attr);\n\t\t\t}\n\t\t\tlet changed = true;\n\t\t\tif ('value' in attr) {\n\t\t\t\tconst desc =\n\t\t\t\t\tReflect.getOwnPropertyDescriptor(target, prop);\n\t\t\t\tif (\n\t\t\t\t\tdesc && 'value' in desc\n\t\t\t\t\t&& recover(attr.value) === recover(desc.value)) {\n\t\t\t\t\tchanged = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst modified = Reflect.defineProperty(target, prop, attr);\n\t\t\tif (changed && modified) {\n\t\t\t\tmarkChange(target, prop);\n\t\t\t}\n\t\t\treturn modified;\n\t\t},\n\t\tgetOwnPropertyDescriptor(target, prop) {\n\t\t\tif (nest === false) {\n\t\t\t\treturn Reflect.getOwnPropertyDescriptor(target, prop);\n\t\t\t}\n\t\t\tmarkRead(target, prop);\n\t\t\treturn Reflect.getOwnPropertyDescriptor(target, prop);\n\t\t},\n\t\tdeleteProperty(target, prop) {\n\t\t\tif (nest === false) {\n\t\t\t\treturn Reflect.deleteProperty(target, prop);\n\t\t\t}\n\t\t\tconst has = Reflect.has(target, prop);\n\t\t\tconst deleted = Reflect.deleteProperty(target, prop);\n\t\t\tif (has && !Reflect.has(target, prop)) {\n\t\t\t\tmarkChange(target, prop);\n\t\t\t\tmarkChange(target, true);\n\t\t\t}\n\t\t\treturn deleted;\n\t\t},\n\t\townKeys(target) {\n\t\t\tif (nest === false) { return Reflect.ownKeys(target); }\n\t\t\tmarkRead(target, true);\n\t\t\treturn Reflect.ownKeys(target);\n\t\t},\n\t\thas(target, prop) {\n\t\t\tif (nest === false) { return Reflect.has(target, prop); }\n\t\t\tmarkRead(target, true);\n\t\t\treturn Reflect.has(target, prop);\n\t\t},\n\t});\n\treturn proxy;\n}\n/** 获取被代理的原始值 */\nexport function recover<T>(v: T): T {\n\tif (!v) { return v; }\n\tif (!isProxyable(v)) { return v; }\n\tlet value = v;\n\ttry {\n\t\tgetValue = v;\n\t\tvalue = (v as any).__monitorable__recover__;\n\t} catch {}\n\tvalue = getValue;\n\tgetValue = false;\n\tif (!value) { return v; }\n\tif (typeof value === 'object') { return value; }\n\tif (typeof value === 'function') { return value; }\n\treturn v;\n}\nexport function equal(a: any, b: any): boolean {\n\treturn recover(a) === recover(b);\n}\n\nexport type ReadMap =  Map<\n\tobject | Function,\n\tSet<string | boolean | symbol>\n>;\n\n/** 已被读取的 */\nlet read: ReadMap | undefined;\n\n/**\n * 标记已读状态\n * @param obj  要标记的对象\n * @param prop 要标记的属性\n */\nexport function markRead(\n\tobj: object | Function,\n\tprop: string | number | boolean | symbol,\n) {\n\tif (!read) { return; }\n\tconst set = getMapValue(read, obj, () => new Set());\n\tif (typeof prop === 'number') {\n\t\tprop = String(prop);\n\t}\n\tset.add(prop);\n}\n/**\n * 监听函数的执行，并将执行过程中读取的对象值设置到 map 中\n * @param fn 要执行的含糊\n * @param map 用于存储被读取对象的 map\n * @param clear 是否在发送错误时清空 map\n */\nexport function observe<T>(\n\tfn: () => T,\n\tmap: ReadMap = new Map(),\n\tclear = false,\n): T {\n\tconst oldRead = read;\n\tread = map;\n\ttry {\n\t\treturn fn();\n\t} catch(e) {\n\t\tif (clear) {\n\t\t\tmap.clear();\n\t\t}\n\t\tthrow e;\n\t} finally {\n\t\tread = oldRead;\n\t}\n}\n\n\nconst watchList = new WeakMap<\n\tobject | Function,\n\tMap<string | boolean | symbol, Set<() => void>>\n>();\n/**\n * 标记属性的修改，同时触发监听函数\n * @param target 要标记的对象\n * @param prop   要标记的属性 特别的，false 表示原型，true 表示成员\n */\nexport function markChange(\n\ttarget: object | Function,\n\tprop: string | number | boolean | symbol,\n) {\n\tif (!target) { return; }\n\tif (!isProxyable(target)) {\n\t\treturn;\n\t}\n\tif (typeof prop === 'number') {\n\t\tprop = String(prop);\n\t} else if (\n\t\ttypeof prop !== 'symbol'\n\t\t&& typeof prop !== 'string'\n\t\t&& typeof prop !== 'boolean'\n\t) {\n\t\treturn;\n\t}\n\n\tconst watch = watchList.get(target)?.get?.(prop);\n\tif (!watch) { return; }\n\tfor (const w of [...watch]) {\n\t\tw();\n\t}\n}\n\n/**\n * 监听对象属性的变化\n * @param target 要监听的对象\n * @param prop   要监听的属性名 特别的，false 表示原型，true 表示成员\n * @param fn     属性改变后触发的函数\n */\nexport function watchProp(\n\ttarget: object | Function,\n\tprop: string | number | boolean | symbol,\n\tcb: () => void,\n): () => void {\n\tif (!target) { return () => {}; }\n\tif (!(typeof target === 'object' || typeof target === 'function')) {\n\t\treturn () => {};\n\t}\n\tif (typeof cb !== 'function') {\n\t\treturn  () => {};\n\t}\n\tif (typeof prop === 'number') {\n\t\tprop = String(prop);\n\t}\n\tif (\n\t\ttypeof prop !== 'symbol'\n\t\t&& typeof prop !== 'string'\n\t\t&& typeof prop !== 'boolean'\n\t) {\n\t\treturn () => {};\n\t}\n\tconst key = prop;\n\ttarget = recover(target);\n\tlet map = watchList.get(target);\n\tif (!map) {\n\t\tmap = new Map();\n\t\twatchList.set(target, map);\n\t}\n\tconst list = getMapValue(map, key, () => new Set());\n\tcb = safeify(cb);\n\tlist.add(cb);\n\tlet removed = false;\n\treturn () => {\n\t\tif (removed) { return; }\n\t\tremoved = true;\n\n\t\t// 从当前列表中移除\n\t\tlist.delete(cb);\n\n\t\t// 从属性关联中删除\n\t\tif (list.size) { return; }\n\t\tif (!map) { return; }\n\t\tmap.delete(key);\n\n\t\t// 映射列表中删除\n\t\tif (map.size) { return; }\n\t\twatchList.delete(target);\n\t};\n\n}\n","import { observe, watchProp, ReadMap } from './state';\nimport { safeify } from './utils';\n\nexport interface Executable<T> {\n\t(): T;\n\tstop(): void;\n}\n/**\n * 创建可监听执行函数\n * @param fn 要监听执行的函数\n * @param cb 当监听的值发生可能改变时触发的回调函数，单如果没有被执行的函数或抛出错误，将会在每次 fn 被执行后直接执行\n */\nexport function createExecutable<T>(\n\tfn: () => T,\n\tcb: (changed: boolean) => void,\n): Executable<T> {\n\tcb = safeify(cb);\n\tlet cancelList: (() => void)[] | undefined;\n\t/** 取消监听 */\n\tfunction cancel() {\n\t\tif (!cancelList) { return false; }\n\t\tconst list = cancelList;\n\t\tcancelList = undefined;\n\t\tlist.forEach(f => f());\n\t\treturn true;\n\t}\n\tfunction trigger() {\n\t\tif (!cancel()) { return; }\n\t\tcb(true);\n\t};\n\tfunction exec() {\n\t\tcancel();\n\t\tconst thisRead: ReadMap = new Map();\n\t\ttry {\n\t\t\treturn observe(fn, thisRead, true);\n\t\t} finally {\n\t\t\tif (thisRead.size) {\n\t\t\t\tcancelList = [];\n\t\t\t\tfor ( let [obj, props] of thisRead) {\n\t\t\t\t\tfor (const p of props) {\n\t\t\t\t\t\tcancelList.push(watchProp(obj, p, trigger));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcb(false);\n\t\t\t}\n\t\t}\n\t}\n\texec.stop = () => {\n\t\tif (!cancel()) { return; }\n\t\tcb(false);\n\t};\n\treturn exec;\n}\n","import { markRead, markChange, recover, encase } from './state';\nimport { safeify } from './utils';\nimport { createExecutable } from './executable';\n\n/** 取消监听的方法 */\nexport interface CancelWatch {\n\t(): void;\n}\n/** 可监听值 */\nexport interface Value<T> {\n\t(): T;\n\t(v: T, mrak?: boolean): T;\n\tvalue: T;\n\twatch(cb: WatchCallback<T, this>): CancelWatch;\n\tstop(): void;\n}\n/** 监听函数 */\nexport interface WatchCallback<T, V extends Value<T> = Value<T>> {\n\t(v: V, stoped: boolean): void;\n}\nconst values = new WeakSet<Value<any>>();\nexport function isValue(x: any): x is Value<any> {\n\treturn values.has(x);\n}\n/** 触发监听 */\ninterface Trigger {\n\t(): void;\n\t/** 是否存在监听函数 */\n\thas(): boolean;\n\t/** 停止监听 */\n\tstop(): void;\n}\nexport interface Options {\n\tproxy?: boolean;\n}\n\n\nfunction createValue<T, V extends Value<T> = Value<T>>(\n\trecover: () => T,\n\tsetValue?: (value: T, markChange: () => void) => void,\n\tstop: () => void = () => {},\n\tchange: () => void = () => {},\n): {value: V, trigger: Trigger} {\n\tfunction set(v: T, marked = false) {\n\t\tif (!setValue) { return; }\n\t\ttry {\n\t\t\tsetValue(v, () => { marked = true; });\n\t\t} finally {\n\t\t\tif (marked) {\n\t\t\t\ttrigger();\n\t\t\t}\n\t\t}\n\t}\n\tfunction get() {\n\t\tmarkRead(value, 'value');\n\t\treturn recover();\n\t}\n\tconst value: V = ((...v: [T] | [T, boolean] | []): T => {\n\t\tif (v.length) {\n\t\t\tset(v[0], v[1]);\n\t\t\treturn v[0];\n\t\t}\n\t\treturn get();\n\t}) as V;\n\tReflect.defineProperty(value, 'value', {\n\t\tget,\n\t\tset,\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t});\n\n\tfunction watch(cb: WatchCallback<T, V>): () => void {\n\t\tif (!callbacks) { return () => {}; }\n\t\tcb = safeify(cb);\n\t\tcallbacks.push(cb);\n\t\tchange();\n\t\tlet cancelled = false;\n\t\treturn () => {\n\t\t\tif (cancelled) { return; }\n\t\t\tcancelled = true;\n\t\t\tif (!callbacks) { return; }\n\t\t\tconst index = callbacks.findIndex(a => a === cb);\n\t\t\tif (index < 0) { return; }\n\t\t\tcallbacks.splice(index, 1);\n\t\t\tchange();\n\t\t};\n\t}\n\tlet callbacks: WatchCallback<T, V>[] | undefined = [];\n\tReflect.defineProperty(value, 'watch', {\n\t\tget() { return watch; },\n\t\tset() {},\n\t\tconfigurable: true,\n\t});\n\tconst trigger = (() => {\n\t\tif (!callbacks) { return; }\n\t\tmarkChange(value, 'value');\n\t\tfor (const cb of [...callbacks]) {\n\t\t\tcb(value, false);\n\t\t}\n\t}) as Trigger;\n\ttrigger.has = () => Boolean(callbacks?.length);\n\ttrigger.stop = () => {\n\t\tif (!callbacks) { return; }\n\t\tconst list = callbacks;\n\t\tcallbacks = undefined;\n\t\tfor (const cb of [...list]) {\n\t\t\tcb(value, true);\n\t\t}\n\t};\n\tvalues.add(value);\n\tlet stoped = false;\n\tvalue.stop = () => {\n\t\tif (stoped) { return; }\n\t\tstoped = true;\n\t\tstop();\n\t\ttrigger.stop();\n\n\t};\n\treturn {value, trigger};\n}\n/**\n * 创建引用值\n * @param value 初始值\n * @param options 选项\n */\nexport function value<T>(\n\tvalue: T,\n\toptions?: Options | boolean,\n): Value<T>;\nexport function value<T>(\n\tdef: T,\n\toptions?: Options | boolean,\n): Value<T> {\n\tconst proxy = options === true || options && options.proxy;\n\tlet source: T;\n\tlet proxyed: T;\n\tconst { value } = createValue<T>(\n\t\t() => proxyed,\n\t\t(v, mark) => {\n\t\t\tif (proxy) { v = recover(v); }\n\t\t\tif (v === source) { return; }\n\t\t\tsource = v;\n\t\t\tproxyed = proxy ? encase(source) : source;\n\t\t\tmark();\n\t\t},\n\t);\n\tvalue(def);\n\treturn value;\n}\n\n/**\n * 创建计算值\n * @param getter 取值方法\n * @param options 选项\n */\nexport function computed<T>(\n\tgetter: () => T,\n\toptions?: Options | boolean,\n): Value<T>;\n/**\n * 创建可赋值计算值\n * @param getter 取值方法\n * @param setter 复制方法\n * @param options 选项\n */\nexport function computed<T>(\n\tgetter: () => T,\n\tsetter: (value: T) => void,\n\toptions?: Options | boolean,\n): Value<T>;\nexport function computed<T>(\n\tgetter: () => T,\n\tsetter?: ((value: T) => void) | Options | boolean,\n\toptions?: Options | boolean,\n): Value<T>;\nexport function computed<T>(\n\tgetter: () => T,\n\tsetter?: ((value: T) => void) | Options | boolean,\n\toptions?: Options | boolean,\n): Value<T> {\n\tif (typeof setter !== 'function') {\n\t\toptions = setter;\n\t\tsetter = undefined;\n\t}\n\tconst setValue = setter;\n\tconst proxy = options === true || options && options.proxy;\n\tlet source: T;\n\tlet proxyed: T;\n\tlet stoped = false;\n\tlet computed = false;\n\tlet trigger: Trigger | undefined;\n\tconst executable = createExecutable(getter, changed => {\n\t\tcomputed = !changed;\n\t\tif (changed  && trigger) {\n\t\t\ttrigger();\n\t\t}\n\t});\n\tfunction run() {\n\t\tcomputed = true;\n\t\ttry {\n\t\t\tsource = executable();\n\t\t\tif (proxy) { source = recover(source); }\n\t\t\tproxyed = proxy ? encase(source) : source;\n\t\t\treturn proxyed;\n\t\t} catch(e) {\n\t\t\tif (!stoped) {\n\t\t\t\tcomputed = false;\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\t}\n\tlet value: Value<T>;\n\t({value, trigger} = createValue<T, Value<T>>(\n\t\t() => computed || stoped ? proxyed : run(),\n\t\tsetValue && (v => setValue(proxy ? recover(v) : v)),\n\t\t() => {\n\t\t\tif (stoped) { return; }\n\t\t\tstoped = true;\n\t\t\tif (computed) { return; }\n\t\t\trun();\n\t\t},\n\t));\n\treturn value;\n\n}\n\nexport function merge<T, V extends Value<T> = Value<T>>(\n\tcb: WatchCallback<T, V>\n): WatchCallback<T, V> {\n\tlet oldValue: any;\n\tlet runed = false;\n\treturn (v, stoped) => {\n\t\tif (stoped) { return cb(v, stoped); }\n\t\tconst newValue = recover(v());\n\t\tif (newValue === oldValue && runed) { return; }\n\t\truned = true;\n\t\toldValue = newValue;\n\t\tcb(v, stoped);\n\t};\n}\n\ntype OffValue<V> = V extends Value<infer T> ? T : V;\n\nexport function mix<T extends object>(\n\tsource: T\n): { [K in keyof T]: OffValue<T[K]>; } {\n\tfor (const k of Reflect.ownKeys(source)) {\n\t\tconst descriptor = Reflect.getOwnPropertyDescriptor(source, k);\n\t\tif (!descriptor) { continue; }\n\t\tif (\n\t\t\t!('value' in descriptor)\n\t\t\t|| 'get' in descriptor\n\t\t\t|| 'set' in descriptor\n\t\t) { continue; }\n\t\tconst value = descriptor.value;\n\t\tif (!isValue(value)) { continue; }\n\t\tdescriptor.get = () => value.value;\n\t\tif (descriptor.writable) {\n\t\t\tdescriptor.set = v => (value as Value<any>).value = v;\n\t\t}\n\t\tdelete descriptor.value;\n\t\tdelete descriptor.writable;\n\t\tReflect.defineProperty(source, k, descriptor);\n\t}\n\treturn source as any;\n}\n"],"names":["printErrorLog","getValue","read","printError","info","print","undefined","console","error","safeify","fn","p","e","getMapValue","map","key","def","has","get","value","set","isProxyable","v","Boolean","includes","encase","nest","original","recover","nestLayer","Infinity","proxy","Proxy","target","prop","receiver","Reflect","modified","markChange","markRead","setPrototypeOf","proto","oldProto","getPrototypeOf","defineProperty","attr","changed","desc","getOwnPropertyDescriptor","deleteProperty","deleted","ownKeys","__monitorable__recover__","obj","Set","String","add","observe","Map","clear","oldRead","watchList","WeakMap","watch","_watchList$get","_watchList$get$get","w","watchProp","cb","list","removed","delete","size","createExecutable","cancelList","cancel","forEach","f","trigger","exec","thisRead","props","push","stop","values","WeakSet","isValue","x","createValue","setValue","change","marked","length","callbacks","cancelled","index","findIndex","a","splice","enumerable","configurable","_callbacks","stoped","getter","setter","options","source","proxyed","computed","executable","run","b","oldValue","runed","newValue","k","descriptor","writable","mark"],"mappings":"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"}